<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>üìù Automatitzaci√≥ Oracle</title>
  <link rel="stylesheet" href="estilsunitats.css">
  <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css" />
</head>
<body>

<header>
  <a href="index.html">
      <!--<img src="https://upload.wikimedia.org/wikipedia/commons/5/50/Oracle_logo.svg" alt="Oracle Logo"> -->
      <img src="imgs/ASGBD.png" alt="M√≤dul ASGBD">
  </a>
  <h1>ASGBD   -    Automatitzaci√≥ de tasques en Oracle</h1>
</header>

<nav>
  <h3>√çndex</h3>
  <a href="#autom">Automatitzaci√≥: Conceptes</a>
  <a href="#blocs">Blocs an√≤nims</a>
  <a href="#editor-bloc-anonim">Editor codi online</a>
  <a href="#variables">Variables</a>
  <a href="#estructures">Estructures de programaci√≥</a>
  <a href="#proc-func">Procediments-funcions</a>
  <a href="#procediments">Procediments en ORACLE</a>
  <a href="#funcions">Funcions en ORACLE</a>
  <a href="#disparadors">Disparadors en ORACLE</a>
  <a href="#seq">Seq√º√®ncies</a>
  <a href="#cursors">Cursors</a>
  <a href="#excepcions">Excepcions</a>
  <a href="#tasques">Tasques automatitzables</a>
  <a href="#altres-recursos">Altres Recursos</a>
</nav>

<main>

  <section id="autom">
    <br><h2> Automatitzaci√≥</h2>
    <p>L'automatitzaci√≥ consisteix a fer tasques de manera sistem√†tica i repetitiva 
      sense que estiga involucrat un usuari en la seua execuci√≥</p>
    <h3>Avantatges Automatitzaci√≥</h3>
      <ul>
        <li>Estalvi de temps</li>
        <li>Reducci√≥ costos administraci√≥</li>
        <li>Reducci√≥ errors ( hum√†)</li>
      </ul>

      <h3>Tipus</h3>
      <ul>
        <li>Programa extern (al SGBD)</li>
        <li>Programa intern : rutina de bbdd + job</li>
      </ul>

      <h3>Rutina</h3>
      <ul>
        <li>Script, gui√≥, programa o seq√º√®ncia de comandos que permeten dur a terme el processament d'unes certes accions</li>
        <li>Quan √©s creada rep un nom que permet que siga invocada tantes vegades com siga necessari</li>
        <li>Van ser introdu√Ødes en la versi√≥ SQL3, o SQL:1999</li>
      </ul>

      <h3>El SGBD deu proporcionar:</h3>
      <ul>
        <li>Eines necess√†ries per a crear rutines</li>
        <li>Eines per a executar les rutines autom√†ticament</li>
      </ul>
 
      <h3>Avantatges rutina interna</h3>
      <ul>
        <li>Rendimen</li>
        <li>Reutilitzaci√≥ (codi)</li>
        <li>Encapsula regles de negoci</li>
        <li>Major seguretat</li>
      </ul>
      <h2>   <h3>Avantatges Automatitzaci√≥</h3>
      <ul>
        <li>Estalvi de temps</li>
        <li>Reducci√≥ costos administraci√≥</li>
        <li>Reducci√≥ errors ( hum√†)</li>
      </ul>
      <h2>Les rutines: S‚Äôhan de Documentar</h2>
      <img src="imgs/important.png" class="imatge-esquerra"  alt="stop" style="width: 20%">
      <h2>QUE ??</h2><p>Descripci√≥ de la tasca, descripci√≥ de par√†metres d‚Äôentrada i eixida, Autor, Versi√≥, Data d‚Äô√∫ltima modificaci√≥, etc..</p>
      <h2>COM ??</h2> <p>Fent servir comentaris en el codi de les rutines. Amb /* */ o  --</p><p>Fent servir documentaci√≥ institucional en qualsevol suport (docs,fulles de c√†lcul,diagrames,etc..)</p>
  
  </section>



  <section id="blocs">
    <br>
    <h2>üßæ Bloc An√≤nim en PL/SQL</h2>
  
    <h3> Qu√® √©s un bloc an√≤nim?</h3>
    <p>
      Un <strong>bloc an√≤nim</strong> √©s una unitat de codi en PL/SQL que:
    </p>
    <ul>
      <li> No t√© nom ni es guarda a la base de dades.</li>
      <li> S‚Äôexecuta una sola vegada i despr√©s desapareix.</li>
      <li> √âs ideal per a proves o per a executar operacions puntuals.</li>
      <li> Pot incloure sent√®ncies SQL, declaracions de variables, control de flux, i gesti√≥ d‚Äôexcepcions.</li>
    </ul>
  
    <h3> Estructura b√†sica d‚Äôun bloc an√≤nim</h3>
    <pre>
  SET SERVEROUTPUT ON;
  
  DECLARE
     vNom VARCHAR2(20) := '&nom';
  BEGIN
     DBMS_OUTPUT.PUT_LINE('Hola ' || vNom);
     DBMS_OUTPUT.PUT_LINE('Benvingut a la programaci√≥ en PL/SQL');
  END;
  .  -- Nom√©s en SQL*Plus!
    </pre>
  
    <p>
      ‚ö†Ô∏è En <strong>SQL*Plus</strong> s‚Äôha de posar un punt (<code>.</code>) al final per enviar-lo al buffer i despr√©s executar-lo amb <code>RUN</code>.  
      En <strong>SQL Developer</strong>, s‚Äôexecuta amb <kbd>F5</kbd> i <strong>no cal posar el punt</strong>.
    </p>
  
    <h3>üí¨ Explicaci√≥ pas a pas</h3>
    <ul>
      <li><code>DECLARE</code>: bloc opcional per declarar variables.</li>
      <li><code> <strong>&</strong>nom</code>: Variable de substituci√≥.</li>
      <li><code>BEGIN</code>: bloc obligatori per executar codi.</li>
      <li><code>DBMS_OUTPUT.PUT_LINE</code>: mostra text a pantalla (cal tenir activat <code>SET SERVEROUTPUT ON</code>).</li>
      <li><code>END;</code>: finalitza el bloc.</li>
      <li><code>.</code>: (nom√©s en SQL*Plus) envia el bloc al buffer per executar-lo.</li>
    </ul>
  <p><strong>&nom</strong> Una variable de substituci√≥ √©s una variable que s'utilitza principalment en eines com SQL*Plus, SQL Developer o Toad, per a permetre que l‚Äôusuari introdu√Øsca un valor en temps d‚Äôexecuci√≥, abans que s'execute un bloc PL/SQL o una sent√®ncia SQL.
    No √©s part del llenguatge PL/SQL com a tal, sin√≥ una funcionalitat d‚Äôaquestes eines per fer scripts m√©s din√†mics i interactius.</p>
    <p><strong>PUT_LINE</strong> √âs un procediment del paquet <strong>DBMS_OUTPUT</strong> d'ORACLE.</p>

    <h3> Exemple senzill</h3>
    <pre>
  SET SERVEROUTPUT ON;
  
  DECLARE
     vData DATE := SYSDATE;
  BEGIN
     DBMS_OUTPUT.PUT_LINE('La data actual √©s: ' || TO_CHAR(vData, 'DD/MM/YYYY'));
  END;
    </pre>
    <p><strong>SYSDATE</strong> √©s una funci√≥ d'ORACLE que torna la data/temps del instant actual</p>
    <p><strong>TO_CHAR</strong> √©s una funci√≥ d'ORACLE que transforma de format DATA a format VARCHAR2 </p>
  
    <h3> Bones pr√†ctiques</h3>
    <ul>
      <li> Documenta el codi amb comentaris (<code>--</code> per una l√≠nia, <code>/* */</code> per m√∫ltiples).</li>
      <li> Fes servir blocs an√≤nims per provar procediments o funcions abans de guardar-los.</li>
      <li> Prova condicions, bucles i excepcions dins blocs an√≤nims abans d'incorporar-ho a rutines emmagatzemades.</li>
    </ul>
  
    <h3> Ordres √∫tils en SQL*Plus</h3>
    <ul>
      <li><code>EDIT</code> ‚Üí edita l‚Äôscript actual</li>
      <li><code>LIST</code> ‚Üí mostra el contingut del buffer</li>
      <li><code>RUN</code> ‚Üí executa el bloc en el buffer (tamb√©  r  o  /)</li>
      <li><code>SAVE fitxer.sql</code> ‚Üí desa l‚Äôscript en un fitxer</li>
      <li><code>GET fitxer.sql</code> ‚Üí carrega un script des d'un fitxer</li>      
      <li><code>start fitxer.sql</code> ‚Üí carrega i executa un script des d'un fitxer</li>      
      <li><code>@fitxer.sql</code> ‚Üí equival a start</li>
    </ul>
    <a href="https://www.codifica.me/sql-plus/"> .. üìò Es pot ampliar amb *Tutorial d' sql*plus .. </a>
  
    <h3> Ordres √∫tils en SQL Developer</h3>
    <ul>
      <li><code>F5</code> ‚Üí executa l'script de la sessi√≥ activa. Mostra el resultat en l‚Äô√†rea de Script Output.</li>
      <li><code>F9</code> ‚Üí executa sent√®ncia (una). Mostra el resultat en l‚Äô√†rea de Resultats.</li>
      <li><code>.</code> ‚Üí En SQL Developer no cal posar un punt al final</li>
      <li>Recorda posar <code>SET SERVEROUTPUT ON;</code> abans del bloc an√≤nim</li>
      
    </ul>


    <h3> Difer√®ncia amb procediments</h3>
    <p>Els blocs an√≤nims no es poden reutilitzar directament, ja que no tenen nom. Per a reutilitzaci√≥, millor usar procediments o funcions.</p>
  
    <h3>üß™ Prova-ho!</h3>
    <p>
      Prova aquest bloc en <strong>SQL Developer</strong>:
    </p>
    <pre>
  DECLARE
     vNom VARCHAR2(20) := 'Ada';
  BEGIN
     DBMS_OUTPUT.PUT_LINE('Hola ' || vNom || '! Bon dia!');
  END;
    </pre>
  </section>
  
  
  <section id="editor-bloc-anonim">
    <h2>üß™ Pr√†ctica interactiva: Bloc An√≤nim</h2>
    <p>
      Prova aqu√≠ mateix la sintaxi d‚Äôun bloc an√≤nim PL/SQL. Es la p√†gina oficial de ORACLE.
    </p>

    <a href="https://livesql.oracle.com/landing/">Simulador de codi de ORACLE</a>

  </section>

  <section id="variables">
    <h2> üóÉÔ∏è Comentaris, Variables i Operacions en PL/SQL</h2>
    <h2>Comentaris</h2>
    <p>L√πs de comentaris √©s un recurs per poder documentar el codi. Com s'ha dit abans, √©s molt importat documentar el codi</p>
    <pre>
      --  En dos guionets es posa un comentari d'una l√≠nia.
      /*  En la barra i l'asterisc es pot
          posar comentaris de m√©s d'una l√≠nia
      */
    </pre>

    <h2>Variables</h2>
   
      <p>Una <strong>variable</strong> en PL/SQL √©s un espai de mem√≤ria per emmagatzemar dades temporals durant l'execuci√≥ d‚Äôun bloc de codi. Pot contindre textos, n√∫meros, dates, etc.</p>
    
      <h4> Estructura b√†sica</h4>
      <pre><code>DECLARE
       nom_variable tipus [:= valor_inicial];
    BEGIN
       -- √∫s de la variable
    END;
    /</code></pre>
    
      <h4> Tipus b√†sics</h4>
      <table>
        <tr>
          <th>Tipus</th>
          <th>Descripci√≥</th>
          <th>Exemple</th>
        </tr>
        <tr>
          <td><code>VARCHAR2(n)</code></td>
          <td>Cadena de text de longitud variable</td>
          <td>'Hola', 'Joan'</td>
        </tr>
        <tr>
          <td><code>NUMBER(p,s)<br>NUMBER(p)<br>NUMBER</code></td>
          <td>N√∫meros amb precisi√≥ i escala</td>
          <td>123, 45.67</td>
        </tr>
        <tr>
          <td><code>DATE</code></td>
          <td>Data i hora</td>
          <td>SYSDATE</td>
        </tr>
        <tr>
          <td><code>BOOLEAN</code></td>
          <td>TRUE, FALSE, NULL (nom√©s PL/SQL)</td>
          <td>TRUE</td>
        </tr>
        <tr>
          <td><code>%TYPE</code></td>
          <td>Tipus igual al d‚Äôuna columna</td>
          <td>taula.columna%TYPE</td>
        </tr>
      </table>
    
      <h4>üß™ Exemple de declaraci√≥</h4>
      <pre><code>DECLARE
       v_nom       VARCHAR2(50) := 'Anna';
       v_edat      NUMBER := 30;
       v_sou       NUMBER(8,2);
       v_data_naix DATE := TO_DATE('1995-06-10', 'YYYY-MM-DD');
       v_es_actiu  BOOLEAN := TRUE;
    BEGIN
       DBMS_OUTPUT.PUT_LINE('Nom: ' || v_nom);
       DBMS_OUTPUT.PUT_LINE('Edat: ' || v_edat);
    END;
    /</code></pre>
    
      <h4> Variables amb <code>%TYPE</code></h4>
      <pre><code>DECLARE
       v_nom_client clients.nom%TYPE;
    BEGIN
       SELECT nom INTO v_nom_client FROM clients WHERE id = 1;
       DBMS_OUTPUT.PUT_LINE('Client: ' || v_nom_client);
    END;
    /</code></pre>
    
      <h4>üõ†Ô∏è Com assignar valors</h4>
      <ul>
        <li><strong>Assignaci√≥ directa:</strong> <code>v_edat := 25;</code></li>
        <li><strong>Amb SELECT INTO:</strong>
          <pre><code>SELECT sou INTO v_sou FROM empleats WHERE id = 5;</code></pre>
        </li>
        <li><strong>Entrada de l‚Äôusuari (SQL Developer):</strong> <code>v_nom := '&amp;nom_usuari';</code></li>
      </ul>
    
      <h4>‚ùó Detalls importants</h4>
      <ul>
        <li>Les variables nom√©s existeixen dins del bloc on es declaren.</li>
        <li>No pots fer <code>SELECT ...</code> sense <code>INTO</code> dins de PL/SQL.</li>
        <li><code>BOOLEAN</code> nom√©s es pot usar dins de PL/SQL, no en SQL est√†ndard. ( ‚ùó si en oracle23 ‚ùó)</li>
      </ul>
  

    <h2>Operacions</h2>
      <h3> Operacions amb Variables en PL/SQL</h3>
    
      <p>Una vegada declarades, les variables en PL/SQL poden utilitzar-se per fer c√†lculs, tractament de text, dates i l√≤gica condicional. Ac√≠ tens exemples clars i √∫tils:</p>
    
      <h3>üìê 1. Operacions aritm√®tiques</h3>
      <p>Per fer sumes, restes, multiplicacions i divisions amb variables de tipus <code>NUMBER</code>:</p>
      <pre><code>DECLARE
       a NUMBER := 10;
       b NUMBER := 3;
       resultat NUMBER;
    BEGIN
       resultat := a + b;
       DBMS_OUTPUT.PUT_LINE('Suma: ' || resultat);
    
       resultat := a - b;
       DBMS_OUTPUT.PUT_LINE('Resta: ' || resultat);
    
       resultat := a * b;
       DBMS_OUTPUT.PUT_LINE('Multiplicaci√≥: ' || resultat);
    
       resultat := a / b;
       DBMS_OUTPUT.PUT_LINE('Divisi√≥: ' || resultat);
    END;
    /</code></pre>
    
      <h3>üî§ 2. Operacions amb cadenes de text</h3>
      <p>Les cadenes (<code>VARCHAR2</code>) es concatenen amb <code>||</code>.</p>
      <pre><code>DECLARE
       nom VARCHAR2(20) := 'Joan';
       cognom VARCHAR2(20) := 'Garcia';
       nom_complet VARCHAR2(50);
    BEGIN
       nom_complet := nom || ' ' || cognom;
       DBMS_OUTPUT.PUT_LINE('Nom complet: ' || nom_complet);
    END;
    /</code></pre>
    
      <h3>üìÖ 3. Operacions amb dates</h3>
      <p>Les dates es poden restar o sumar, on 1 unitat √©s 1 dia:</p>
      <pre><code>DECLARE
       data_naix DATE := TO_DATE('2000-01-01', 'YYYY-MM-DD');
       avui      DATE := SYSDATE;
       edat_dies NUMBER;
    BEGIN
       edat_dies := avui - data_naix;
       DBMS_OUTPUT.PUT_LINE('Dies des de naixement: ' || edat_dies);
    
       DBMS_OUTPUT.PUT_LINE('Dem√† ser√†: ' || (avui + 1));
    END;
    /</code></pre>
    
      <h3> 4. Operacions l√≤giques</h3>
      <p>Amb variables <code>BOOLEAN</code>, pots fer condicions:</p>
      <pre><code>DECLARE
       actiu BOOLEAN := TRUE;
       menor BOOLEAN := FALSE;
    BEGIN
       IF actiu AND NOT menor THEN
          DBMS_OUTPUT.PUT_LINE('L‚Äôusuari est√† actiu i no √©s menor.');
       END IF;
    END;
    /</code></pre>

     <p>Pots utilitzar variables <code>BOOLEAN</code> o fer comparacions entre nombres, textos o dates amb els operadors seg√ºents:</p>

    <ul>
      <li><code>=</code> igualtat</li>
      <li><code>&lt;&gt;</code> diferent</li>
      <li><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
      <li><code>AND</code>, <code>OR</code>, <code>NOT</code></li>
    </ul>

      <h3>üß™ Exemple 1: comparacions num√®riques</h3>
      <pre><code>DECLARE
      nota NUMBER := 7.5;
    BEGIN
      IF nota >= 5 THEN
          DBMS_OUTPUT.PUT_LINE('Aprovat');
      ELSE
          DBMS_OUTPUT.PUT_LINE('Susp√®s');
      END IF;
    END;
    /</code></pre>

      <h3>üß™ Exemple 2: condicions m√∫ltiples</h3>
      <pre><code>DECLARE
      edat NUMBER := 16;
      autoritzat BOOLEAN;
    BEGIN
      autoritzat := (edat >= 18);
      IF autoritzat THEN
          DBMS_OUTPUT.PUT_LINE('Pot entrar');
      ELSE
          DBMS_OUTPUT.PUT_LINE('Acc√©s denegat');
      END IF;
    END;
    /</code></pre>

      <h3>üß™ Exemple 3: combinaci√≥ amb <code>AND</code> i <code>OR</code></h3>
      <pre><code>DECLARE
      edat NUMBER := 20;
      carnet_conduir BOOLEAN := TRUE;
    BEGIN
      IF edat >= 18 AND carnet_conduir THEN
          DBMS_OUTPUT.PUT_LINE('Pot conduir legalment');
      ELSE
          DBMS_OUTPUT.PUT_LINE('No pot conduir');
      END IF;
    END;
    /</code></pre>

      <h3>üß™ Exemple 4: comparaci√≥ de cadenes</h3>
      <pre><code>DECLARE
      rol VARCHAR2(20) := 'admin';
    BEGIN
      IF rol = 'admin' THEN
          DBMS_OUTPUT.PUT_LINE('Acc√©s complet');
      ELSE
          DBMS_OUTPUT.PUT_LINE('Acc√©s limitat');
      END IF;
    END;
    /</code></pre>

   
      <h3> 5. Operacions combinades</h3>
      <p>Pots combinar n√∫meros i textos, per exemple per calcular salaris:</p>
      <pre><code>DECLARE
       nom VARCHAR2(20) := 'Laura';
       hores NUMBER := 5;
       sou_hora NUMBER := 12.5;
       total_sou NUMBER;
    BEGIN
       total_sou := hores * sou_hora;
       DBMS_OUTPUT.PUT_LINE(nom || ' cobrar√† ' || total_sou || ' euros.');
    END;
    /</code></pre>
    
      <p>‚ú® Pots provar aquests blocs en Oracle SQL Developer amb <strong>F5</strong> per veure el resultat a <em>DBMS Output</em>.</p>

  </section>



  
  <section id="estructures">
    <h2>üîÅ Estructures de control en PL/SQL</h2>
  
    <p>Les estructures de control s√≥n fonamentals per controlar el flux d'execuci√≥ d‚Äôun bloc de codi PL/SQL. Oracle suporta m√∫ltiples tipus:</p>
  
    <h3> Condicionals</h3>
  
    <h4> Estructura IF</h4>
    <pre>
  IF condicio THEN
     instruccions;
  ELSIF altra_condicio THEN
     instruccions;
  ELSE
     instruccions;
  END IF;
    </pre>
  
    <h4> Exemple IF (üß™ Prova-ho!)</h3>
    <pre>
  DECLARE
     edat NUMBER := 20;
  BEGIN
     IF edat >= 18 THEN
        DBMS_OUTPUT.PUT_LINE('Ets major d''edat');
     ELSE
        DBMS_OUTPUT.PUT_LINE('Ets menor');
     END IF;
  END;
    </pre>
    
    <h4> Estructura CASE</h4>
    <pre>
  CASE expressio
     WHEN valor1 THEN instruccions;
     WHEN valor2 THEN instruccions;
     ELSE instruccions;
  END CASE;
    </pre>
  
    <h4> Exemple CASE  (üß™ Prova-ho!)</h4>
    <pre>
  DECLARE
     nota NUMBER := 7;
  BEGIN
     CASE
        WHEN nota >= 9 THEN DBMS_OUTPUT.PUT_LINE('Excel¬∑lent');
        WHEN nota >= 5 THEN DBMS_OUTPUT.PUT_LINE('Aprovat');
        ELSE DBMS_OUTPUT.PUT_LINE('Susp√®s');
     END CASE;
  END;
    </pre>
  
    <h3>üîÅ Bucles</h3>
  
    <h4>üîÑ LOOP b√†sic (amb sortida manual)</h4>
    <pre>
  LOOP
     instruccions;
     EXIT WHEN condicio;
  END LOOP;
    </pre>
  
    <h4> Exemple LOOP (üß™ Prova-ho!)</h4>
    <pre>
  DECLARE
     i NUMBER := 1;
  BEGIN
     LOOP
        DBMS_OUTPUT.PUT_LINE('Iteraci√≥: ' || i);
        i := i + 1;
        EXIT WHEN i > 5;
     END LOOP;
  END;
    </pre>
  
    <h4> WHILE LOOP</h4>
    <pre>
  WHILE condicio LOOP
     instruccions;
  END LOOP;
    </pre>
  
    <h4> Exemple WHILE   (üß™ Prova-ho!)</h4>
    <pre>
  DECLARE
     i NUMBER := 1;
  BEGIN
     WHILE i <= 3 LOOP
        DBMS_OUTPUT.PUT_LINE('Valor: ' || i);
        i := i + 1;
     END LOOP;
  END;
    </pre>
  
    <h4> FOR LOOP</h4>
    <pre>
  FOR variable IN inici..final LOOP
     instruccions;
  END LOOP;
    </pre>
  
    <h4> Exemple FOR</h4>
    <pre>
  BEGIN
     FOR i IN 1..4 LOOP
        DBMS_OUTPUT.PUT_LINE('Posici√≥: ' || i);
     END LOOP;
  END;
    </pre>
  
    <h3> Notes addicionals</h3>
    <ul>
      <li><strong>EXIT WHEN</strong> ‚Üí surt d‚Äôun bucle en una condici√≥</li>
      <li><strong>CONTINUE</strong> ‚Üí salta a la seg√ºent iteraci√≥ (a partir de Oracle 11g)</li>
      <li>Els bucles poden ser <strong>anidats</strong> i combinen amb IF o CASE</li>
    </ul>
  
    <h3> Bon √∫s d‚Äôestructures</h3>
    <ul>
      <li> Usa `FOR` si saps quantes vegades vols repetir</li>
      <li> Usa `WHILE` si depens d‚Äôuna condici√≥ externa</li>
      <li> Usa `IF` per bifurcar el comportament del codi</li>
      <li>‚ö†Ô∏è Evita bucles infinits, assegura sempre una condici√≥ de sortida</li>
    </ul>
  </section>
  

  <section id="proc-func">
    <h2>‚öôÔ∏è Procediments, Funcions i Triggers</h2>
  
    <h3> Definicions r√†pides</h3>
    <ul>
      <li><strong>Procediment:</strong> bloc PL/SQL que realitza una acci√≥, pot tenir par√†metres per√≤ no retorna valor directament.</li>
      <li><strong>Funci√≥:</strong> com un procediment, per√≤ <strong>retorna un valor</strong> mitjan√ßant <code>RETURN</code>.</li>
      <li><strong>Trigger:</strong> bloc de codi que s'executa autom√†ticament <strong>quan es produeix un esdeveniment</strong> sobre una taula (INSERT, UPDATE, DELETE).</li>
    </ul>
  
    <hr>
    <p> ‚ùó Un usuari necessita tindre perm√≠s per executar rutines, o per crear-les i executar-es !!</p>
    <pre>GRANT CREATE PROCEDURE, CREATE TRIGGER TO <usu>;
      (si te perm√≠s de crear, tamb√© pot executar)
      GRANT EXECUTE ON <esquema>.<procedim> TO <usu> [WITH GRANT OPTION];</pre>
    <p>El perm√≠s <strong>CREATE PROCEDURE</strong> val per procediments, I tamb√© per funcions</p>    
    <p>El perm√≠s <strong>CREATE TRIGGER</strong> val per disparadors</p>    
    <hr>
  
    <h3> PROCEDURE ‚Äì Procediment</h3>
    <p>Els procediments <strong>NO retornen valor</strong> i NO poden ser cridades dins SELECT o expressions. 
      Poden ser cridats des de dins d'un bloc an√≤nim, directament des de linea d'ordres sqlplus o SQL Developer, 
      o des de dins d'un altre procediment o funci√≥</p>
      <h4>Exemples</h4>
      <pre>
    DBMS_OUTPUT.PUT_LINE('Susp√®s')
    afegir_client('Maria', 'Gonzalez', '123456789');  
    actualitzar_sou(101, 3000);  </pre>

    <hr>
      <h3> FUNCTION ‚Äì Funci√≥</h3>
      <h4> Difer√®ncia clau:</h4>
    <p>Les funcions <strong>retornen un valor</strong> i poden ser cridades dins SELECT o expressions.</p>
    <h4>Exemples</h4>
    <pre>
    data_actual := SYSDATE;
    valor_aleatori := DBMS_RANDOM.VALUE(1, 100);
    data_convertida := TO_DATE('2025-04-20', 'YYYY-MM-DD');

    select upper(nom) , sysdate, sou from empleats;
    SELECT CONCAT(nom, ' ', cognom) FROM clients;
    select sysdate from dual;      </pre>
  
    <hr>
  
    <h3> TRIGGER ‚Äì Disparador</h3>
    <h4> Difer√®ncia clau:</h4>
    <p>Els trigger <strong>no retornen un valor, i no se'ls pot cridar</strong> Son blocs de codi amb nom que son cridats
       automaticament pel sistema quan passa algun esdeveniment.</p>
    <h4>Exemples</h4>
   <pre>
    -- Al Inserir un nou empleat es disparara el trigger associat 
    -- al INSERT en la taula EMPLEATS
    INSERT INTO empleats (id_empleat, nom, cognom, sou)   
    VALUES (101, 'Joan', 'Garc√≠a', 2500);
    -- En este moment, el sistema crida al trigger
    </pre>
    
  </section>
    


<section id="procediments">
  <h2>‚öôÔ∏è Procediments en PL/SQL</h2>

  <h3> Qu√® √©s un procediment?</h3>
  <p>
    Un <strong>procediment</strong> √©s un bloc de codi PL/SQL <strong>emmagatzemat amb un nom</strong> que es pot cridar per executar una acci√≥. 
    Pot rebre par√†metres i fer servir sent√®ncies SQL, estructures de control, bucles, excepcions, etc.
  </p>

  <h3> Estructura b√†sica</h3>
  <pre>
CREATE [OR REPLACE] PROCEDURE nom_proc (
    param1 [IN | OUT | IN OUT] tipus,
    ...
) IS
BEGIN
   -- Codi del procediment
END nom_proc;
  </pre>

  <h4> Tipus de par√†metres:</h4>
  <ul>
    <li><code>IN</code>: entrada (per defecte)</li>
    <li><code>OUT</code>: sortida</li>
    <li><code>IN OUT</code>: entrada i sortida</li>
  </ul>
  <p>Sols vorem els IN, que a m√©s a m√©s, no cal posar la paraula IN perqu√® √©s el tipus per defecte</p>

  <h3> üß™ Exemple senzill</h3>
  <pre>
CREATE OR REPLACE PROCEDURE saluda (nom VARCHAR2) IS
BEGIN
   DBMS_OUTPUT.PUT_LINE('Hola, ' || nom || '!');
END;
  </pre>

  <p><strong>Execuci√≥:</strong></p>
  <pre>
BEGIN
   saluda('Joan');
END;
  </pre>
  <P>O tamb√© amb  <code>execute</code></P>
  <pre>execute mostrar_salutacio('Ada');</pre>

  <h3>üîç Consultar procediments</h3>
  <ul>
    <li> Llistar procediments de l‚Äôusuari:</li>
    <pre>
SELECT object_name FROM user_objects WHERE object_type = 'PROCEDURE';
    </pre>

    <li>üëÄ Consultar par√†metres d‚Äôun procediment:</li>
    <pre>
SELECT argument_name, in_out, data_type
FROM user_arguments
WHERE object_name = 'CALCULA_DOBLE';
    </pre>
  </ul>

  <h3> Desar en fitxer i executar</h3>
  <p>Pots escriure un procediment en un fitxer <code>.sql</code> i executar-lo amb:</p>
  <pre>@proc_saluda.sql</pre>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Dona noms clars i significatius</li>
    <li> Documenta el comportament i els par√†metres</li>
    <li> Gestiona excepcions amb <code>EXCEPTION</code> per capturar errors</li>
    <li>‚ö†Ô∏è Evita fer massa coses dins d‚Äôun sol procediment ‚Üí separa funcionalitats</li>
  </ul>

  <h3> Exemple complet amb control d‚Äôerrors</h3>
  <pre>
CREATE OR REPLACE PROCEDURE insereix_alumne (
   nom IN VARCHAR2,
   edat IN NUMBER
) IS
BEGIN
   INSERT INTO alumnes(nom, edat) VALUES (nom, edat);
   DBMS_OUTPUT.PUT_LINE('Alumne inserit correctament.');
EXCEPTION
   WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
  </pre>

  <h3> Esborrar un procediment</h3>
  <pre>
  DROP PROCEDURE nom_proc;    </pre>

  <h3> Formes de cridar / invocar un procediment</h3>
  <ul>
    <li>Notaci√≥ posicional</li>
    <li>Notaci√≥ nominal</li>
  </ul>
  <pre>
    afegir_client('Joan', 'Garc√≠a', '123456789');
    afegir_client( p_nom => 'Joan', p_cognom => 'Garc√≠a', p_telefon => '123456789');
    o
    afegir_client(p_telefon => '123456789', p_nom => 'Joan', p_cognom => 'Garc√≠a');    </pre>
    <p>Totes s√≥n correctes</p>

</section>


<section id="funcions">
  <h2> Funcions en PL/SQL</h2>

  <h3>üìò Qu√® √©s una funci√≥?</h3>
  <p>
    Una <strong>funci√≥</strong> √©s un bloc de codi PL/SQL que <strong>rep zero o m√©s par√†metres</strong> i <strong>retorna un valor</strong>.
    A difer√®ncia dels procediments, les funcions es poden cridar dins sent√®ncies SQL i expressions.
  </p>
  <p>Al igual que en els procediments existeixen funcions predefinides que podem utilitzar en oracle</p>

  <table>
    <thead>
      <tr >
        <th>Tipus de Funcions</th>
        <th>Funcions</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Funcions Num√®riques</strong></td>
        <td>ROUND, TRUNC, MOD, SQRT, POWER, SIGN, ABS</td>
      </tr>
      <tr>
        <td><strong>Funcions de Cadenes (Strings)</strong></td>
        <td>LOWER, UPPER, TRIM, SUBSTR, LENGTH, REPLACE, INSTR, TRANSLATE, CHR, ASCII</td>
      </tr>
      <tr>
        <td><strong>Funcions per treballar amb NULL</strong></td>
        <td>NVL, NVL2, NULLIF, COALESCE</td>
      </tr>
      <tr>
        <td><strong>Funcions de Dates</strong></td>
        <td>SYSDATE, LAST_DAY, EXTRACT, ADD_MONTHS</td>
      </tr>
      <tr>
        <td><strong>Funcions de Conversi√≥</strong></td>
        <td>TO_NUMBER, TO_DATE, TO_CHAR</td>
      </tr>
    </tbody>
  </table>
  
  <p>I, al igual que en els procediments , podem definir noves funcions (funcions definides per l'usuari)</p>
  <p>Hem de tindre en compte, que una funci√≥ necessita <strong>saber</strong> quin tipus de dada va a retornar, i, 
    a m√©s a m√©s, en algun punt del cos de la funci√≥, ha de <strong>retornar</strong> una dada d'aquest tipus</p>

  <h3> Estructura b√†sica</h3>
  <pre>
CREATE [OR REPLACE] FUNCTION nom_func (  par√†metres  ) 
RETURN tipus 
IS
BEGIN
    -- codi
    RETURN valor;
END nom_func;
  </pre>

  <h3> Exemple simple</h3>
  <pre>
CREATE OR REPLACE FUNCTION suma ( a NUMBER, b  NUMBER ) 
RETURN NUMBER 
IS
BEGIN
   RETURN a + b;
END;
  </pre>

  <h4>Exemple Crida dins d‚Äôun bloc:</h4>
  <pre>
DECLARE
   resultat NUMBER;
BEGIN
   resultat := suma(4, 5);
   DBMS_OUTPUT.PUT_LINE('Resultat: ' || resultat);
END;
  </pre>

  <h4> Exemple Crida dins d'un SELECT</h4>
  <pre>
SELECT suma(10, 20) FROM dual;
  </pre>

  <h3> Exemple real: calcular salari amb plus</h3>
  <pre>
CREATE OR REPLACE FUNCTION salari_total ( base NUMBER, plus NUMBER DEFAULT 0 ) 
RETURN NUMBER 
IS
BEGIN
   RETURN base + plus;
END;
  </pre>

  <p>Crida:</p>
  <pre>
SELECT salari_total(1500, 200) FROM dual;
  </pre>

  <h3> Tipus de par√†metres</h3>
  <ul>
    <li><code>IN</code>: entrada (per defecte)</li>
    <li><code>OUT</code> i <code>IN OUT</code> no es poden fer servir a funcions que es cridin dins SQL</li>
  </ul>

  <h3>‚ö†Ô∏è Limitacions</h3>
  <ul>
    <li>Les funcions que es criden des de SQL <strong>no poden modificar dades</strong> (no poden fer INSERT, UPDATE o DELETE)</li>
    <li>Han de ser deterministes: el resultat ha de dependre nom√©s dels valors d‚Äôentrada</li>
  </ul>

  <h3>üì• Consulta de funcions</h3>
  <pre>
-- Funcions de l‚Äôusuari
SELECT object_name FROM user_objects WHERE object_type = 'FUNCTION';

-- Arguments d‚Äôuna funci√≥
SELECT argument_name, data_type, in_out
FROM user_arguments
WHERE object_name = 'SUMA';
  </pre>

  <h3>üß™ Exemple amb condici√≥</h3>
  <pre>
CREATE OR REPLACE FUNCTION es_parell (n IN NUMBER)
RETURN VARCHAR2 IS
BEGIN
   IF MOD(n, 2) = 0 THEN
      RETURN 'S√≠';
   ELSE
      RETURN 'No';
   END IF;
END;
  </pre>

  <p>Crida:</p>
  <pre>SELECT es_parell(8) FROM dual;</pre>

  <h3> Com cridar funcions:</h3>
  <ul>
    <li>‚úîÔ∏è Dins <code>SELECT</code>, <code>WHERE</code>, <code>ORDER BY</code></li>
    <li>‚úîÔ∏è Assignant a una variable dins un bloc</li>
    <li>‚ùå No es poden fer servir dins DML (si tenen codi que modifica dades)</li>
  </ul>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Utilitza noms clars i descriptius</li>
    <li> Fes servir <code>RETURN</code> nom√©s una vegada si √©s possible</li>
    <li> Documenta qu√® fa la funci√≥ i qu√® retorna</li>
    <li>‚ö†Ô∏è Evita fer INSERT/UPDATE dins funcions si s‚Äôhan de cridar des de SQL</li>
  </ul>

  <h3>üß™ Pr√†ctica combinada</h3>
  <p>Calcular l‚ÄôIRPF aplicat a un salari i retornar-lo:</p>
  <pre>
CREATE OR REPLACE FUNCTION calcula_irpf (
   salari IN NUMBER
) RETURN NUMBER IS
BEGIN
   RETURN salari * 0.15;
END;
  </pre>

  <p>
    Aquesta funci√≥ es pot cridar dins un SELECT per veure quants impostos es retenen:
  </p>
  <pre>
SELECT nom, calcula_irpf(salari) AS irpf
FROM empleats;
  </pre>

  <h3>üîç Consultes √∫tils</h3>
  <pre>
-- Veure procediments i funcions de l'usuari
SELECT object_name, object_type
FROM user_objects
WHERE object_type IN ('PROCEDURE', 'FUNCTION');   </pre>  

<h3>üßπ Esborrar una funci√≥</h3>
<pre>DROP FUNCTION nom_de_la_funcio; </pre>
<p>‚ö†Ô∏è Consideracions:</p>
<ul>
  <li>Assegura‚Äôt que no hi ha cap procediment, vista o altre objecte que depenga d‚Äôeixa funci√≥ abans d‚Äôeliminar-la.</li>
  <li>Si la funci√≥ no existeix, Oracle donar√† un error</li>
</ul>

</section>




<section id="disparadors">
  <h2>üö® Disparadors (Triggers) en Oracle</h2>

  <h3>üìò Qu√® √©s un trigger?</h3>
  <p>
    Un <strong>trigger</strong> √©s un bloc de codi PL/SQL que s‚Äôexecuta autom√†ticament quan es produeix un <strong>esdeveniment</strong> 
    (com un INSERT, UPDATE o DELETE) sobre una taula o vista.
  </p>

  <h3> El bloc de codi del trigger s'executara:</h3>
  <ul>
    <li><strong>BEFORE</strong>: abans de l‚Äôesdeveniment</li>
    <li><strong>AFTER</strong>: despr√©s de l‚Äôesdeveniment</li>
    <li><strong>INSTEAD OF</strong>: per a vistes, substitueix l‚Äôacci√≥</li>
  </ul>
  <p>Segons el cas, es poden utilitzar valors d‚Äôuna fila abans de la operaci√≥ o despr√©s de l‚Äôoperaci√≥: :new i :old</p>

  <h3> Nivells d‚Äôactuaci√≥</h3>
  <ul>
    <li> <strong>Fila a fila</strong> ‚Üí actua per cada fila afectada (s'indica posant FOR EACH ROW)</li>
    <li> <strong>Per esdeveniment</strong> ‚Üí actua una sola vegada per operaci√≥ (s'indica no posant res)</li>
  </ul>
  
  <h3> Sintaxi b√†sica (fila a fila)</h3>
  <pre>
CREATE OR REPLACE TRIGGER nom_trigger
BEFORE INSERT OR UPDATE OR DELETE
ON nom_taula
FOR EACH ROW
BEGIN
   -- accions amb :NEW i :OLD
END;
  </pre>

  <h3>üß™ Exemple: trigger de control INSERT</h3>
  <pre>
CREATE OR REPLACE TRIGGER log_insercio
AFTER INSERT ON alumnes
FOR EACH ROW
BEGIN
   DBMS_OUTPUT.PUT_LINE('Nou registre afegit: ' || :NEW.nom);
END;
  </pre>
  <p><code>:NEW</code> i <code>:OLD</code> representen els valors nous i antics respectivament per a cada fila.</p>
  <h3> Exemple: impedir valors negatius</h3>
  <pre>
CREATE OR REPLACE TRIGGER evitar_negatius
BEFORE INSERT OR UPDATE ON productes
FOR EACH ROW
BEGIN
   IF :NEW.preu < 0 THEN
      RAISE_APPLICATION_ERROR(-20001, 'El preu no pot ser negatiu');
   END IF;
END;
  </pre>

  <h3> Exemple: trigger d‚Äôauditoria</h3>
  <p>Crear una taula d‚Äôauditoria:</p>
  <pre>
CREATE TABLE aud_alumnes (
   usuari   VARCHAR2(30),
   data_op  DATE,
   accio    VARCHAR2(10)
);
  </pre>

  <p>Trigger que afegeix registre:</p>
  <pre>
CREATE OR REPLACE TRIGGER audita_alumnes
AFTER INSERT OR DELETE ON alumnes
FOR EACH ROW
BEGIN
   INSERT INTO aud_alumnes VALUES (
      USER,
      SYSDATE,
      CASE
         WHEN INSERTING THEN 'INSERT'
         WHEN DELETING THEN 'DELETE'
      END
   );
END;
  </pre>
 
  <h3>üîé Consultes √∫tils</h3>
  <pre>
-- Veure triggers de l‚Äôusuari actual
SELECT trigger_name, table_name, triggering_event, status
FROM user_triggers;

-- Consultar codi
SELECT trigger_body FROM user_triggers WHERE trigger_name = 'LOG_INSERCIO';
  </pre>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Usa noms clars i descripci√≥ funcional</li>
    <li> Documenta el comportament del trigger</li>
    <li> Evita codi complex o accions que modifiquin altres taules si no √©s necessari</li>
    <li> Controla el rendiment: massa triggers poden degradar l‚Äôefici√®ncia</li>
    <li> Si cal registrar accions, fes servir una taula d‚Äôauditoria</li>
  </ul>

  <h3>üõ†Ô∏è Activaci√≥ i desactivaci√≥ de triggers</h3>
  <pre>
-- Desactivar
ALTER TRIGGER log_insercio DISABLE;

-- Activar
ALTER TRIGGER log_insercio ENABLE;

-- Eliminar
DROP TRIGGER log_insercio;
  </pre>
</section>




<section id="seq">
  <h2> Seq√º√®ncies en Oracle</h2>

  <h3>üìò Qu√® √©s una seq√º√®ncia?</h3>
  <p>
    Una <strong>seq√º√®ncia</strong> √©s un objecte de base de dades que genera una s√®rie de valors num√®rics consecutius, normalment 
    usats per a claus prim√†ries, codis √∫nics o control d‚Äôidentificadors.  
    √âs l‚Äôequivalent a un <em>autoincrement</em> en altres SGBD.
  </p>

  <h3> Crear una seq√º√®ncia</h3>
  <pre>
   -- Donar perm√≠s
   GRANT CREATE SEQUENCE TO usuari;
   -- Crear seq√º√®ncia 
  CREATE SEQUENCE seq_alumnes START WITH 1 INCREMENT BY 1 
  -- Esborrar seq√º√®ncia
  DROP SEQUENCE seq_alumnes;  </pre>

  <h3> √ös de la seq√º√®ncia</h3>
  <p>Per obtenir el seg√ºent valor (es pot fer servir a INSERTs):</p>
  <pre>
seq_alumnes.NEXTVAL </pre>

  <p>Per consultar el valor actual (despr√©s d'haver fet NEXTVAL com a m√≠nim una vegada):</p>
  <pre>
seq_alumnes.CURRVAL   </pre>

  <h4> Exemple d‚Äô√∫s en una inserci√≥</h4>
  <pre>
INSERT INTO alumnes (id, nom, edat)  VALUES (seq_alumnes.NEXTVAL, 'Laia', 21);   </pre>

  <h3>üîç Consultar seq√º√®ncies existents</h3>
  <pre>
-- Seq√º√®ncies de l‚Äôusuari
SELECT sequence_name, min_value, max_value, increment_by
FROM user_sequences;    </pre>

  <h3>‚öôÔ∏è Modificar una seq√º√®ncia</h3>
  <pre>
ALTER SEQUENCE seq_alumnes  INCREMENT BY 5 ;  </pre>

  <h3>üóëÔ∏è Eliminar una seq√º√®ncia</h3>
  <pre>
DROP SEQUENCE seq_alumnes;   </pre>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Usa <code>NOCYCLE</code> per evitar duplicats si no vols que torni a comen√ßar</li>
    <li> Usa <code>CACHE</code> per millor rendiment en entorns grans (ex: <code>CACHE 20</code>)</li>
    <li> No facis servir <code>CURRVAL</code> abans d‚Äôhaver cridat <code>NEXTVAL</code> en la sessi√≥</li>
    <li> Dona noms clars i relacionats amb la taula (ex: <code>SEQ_FACTURES</code>)</li>
  </ul>

  <h3> Exemple complet</h3>
  <pre>
CREATE SEQUENCE seq_factura START WITH 1000 INCREMENT BY 10 ;
-- Inserci√≥ amb NEXTVAL
INSERT INTO factures (id, data_emissio) VALUES (seq_factura.NEXTVAL, SYSDATE);   </pre>

<h3>Identity Column</h3>
<p>Una <strong>identity column</strong>  √©s un altre mecanisme d‚Äôoracle per generar valors sencers seq√ºencials √∫nics i
   assignar-li'ls a camps num√®rics; s'utilitzen generalment per a les claus prim√†ries de les taules 
   garantint que els seus valors no es repetisquen.</p>
<pre>CREATE TABLE empleados (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY
  PRIMARY KEY,
  .......);</pre>

  <table>
    <thead style="background-color: #f2f2f2;">
      <tr>
        <th>Caracter√≠stica</th>
        <th>SEQUENCE</th>
        <th>IDENTITY Column</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Definici√≥</strong></td>
        <td>Objecte independent que genera valors num√®rics seq√ºencials.</td>
        <td>Columna d'una taula que genera autom√†ticament valors √∫nics.</td>
      </tr>
      <tr>
        <td><strong>√ös principal</strong></td>
        <td>Generar claus prim√†ries o valors seq√ºencials a voluntat.</td>
        <td>Generar autom√†ticament un valor √∫nic per fila nova.</td>
      </tr>
      <tr>
        <td><strong>Com s'utilitza</strong></td>
        <td>Cal cridar `nom_seq.NEXTVAL` expl√≠citament en la inserci√≥.</td>
        <td>Oracle gestiona el valor autom√†ticament (amb `GENERATED ALWAYS` o `BY DEFAULT`).</td>
      </tr>
      <tr>
        <td><strong>Control de valor</strong></td>
        <td>L'usuari decideix quan i com consumir el seg√ºent valor.</td>
        <td>El valor s'incrementa autom√†ticament amb cada inserci√≥ (segons la configuraci√≥).</td>
      </tr>
      <tr>
        <td><strong>Flexibilitat</strong></td>
        <td>Molt flexible: pot ser utilitzada per diferents taules o processos.</td>
        <td>Est√† lligada a una sola taula i columna.</td>
      </tr>
      <tr>
        <td><strong>Exemple de creaci√≥</strong></td>
        <td><code>CREATE SEQUENCE seq_client_id START WITH 1 INCREMENT BY 1;</code></td>
        <td><code>id NUMBER GENERATED BY DEFAULT AS IDENTITY</code></td>
      </tr>
      <tr>
        <td><strong>Compartici√≥ entre taules</strong></td>
        <td>Es pot usar en m√∫ltiples taules.</td>
        <td>Nom√©s es pot usar en una taula espec√≠fica.</td>
      </tr>
    </tbody>
  </table>
    

</section>




<section id="cursors">
  <h2> Cursors en PL/SQL</h2>

  <h3>üìò Qu√® √©s un cursor?</h3>
  <p>
    Un <strong>cursor</strong> √©s un mecanisme de PL/SQL que permet <strong>rec√≥rrer m√∫ltiples files</strong>
     retornades per una consulta <code>SELECT</code>.
  </p>
  <p>Serveix per treballar fila a fila amb el conjunt de resultats, com un bucle sobre una taula.</p>

  <h3> Tipus de cursors</h3>
  <ul>
    <li><strong>Impl√≠cits:</strong> creats autom√†ticament per Oracle per a sent√®ncies DML (INSERT, UPDATE...)</li>
    <li><strong>Expl√≠cits:</strong> definits manualment per l‚Äôusuari per tractar SELECTs que tornen m√∫ltiples files</li>
    <li><strong>FOR cursors:</strong> simplificaci√≥ de l‚Äô√∫s expl√≠cit</li>
  </ul>

  <hr>
  <h3> Cursors impl√≠cits</h3>
  <p>No es declaren, sols tornen un resultat o fila:</p>
  <pre> SELECT DESCRIPCION INTO vdescripcion from PAISES WHERE CO_PAIS = 'ESP';   </pre>

<p>Els cursors impl√≠cits nom√©s poden retornar una √∫nica fila. En cas que es retorne m√©s d'una fila 
  (o cap fila) es produir√† una excepci√≥: NO_DATA_FOUND o TOO_MANY_ROWS</p>

  <p>Si no sabem si va a tornar cap fila o m√©s d'una, es pot comprobar abans amb</p>
  <pre>SELECT count(*) INTO vcant from factura WHERE idcli = 'V00923';</pre>
  <p>O utilitzar una EXCEPTION i preguntar per %FOUND</p>

  <h3> Atributs √∫tils</h3>
  <ul>
    <li><code>%FOUND</code> ‚Üí si s‚Äôha trobat almenys una fila</li>
    <li><code>%NOTFOUND</code> ‚Üí si no s‚Äôha trobat cap fila</li>
    <li><code>%ROWCOUNT</code> ‚Üí nombre de files tractades</li>
    <li><code>%ISOPEN</code> ‚Üí indica si el cursor est√† obert</li>
  </ul>

  <hr>
  <h3> √ös d‚Äôun cursor expl√≠cit</h3>
  <p><strong>Passos:</strong></p>
  <ol>
    <li>Declarar el cursor</li>
    <li>Obrir-lo</li>
    <li>Llegir fila a fila</li>
    <li>Tancar-lo</li>
  </ol>

  <h4> Exemple complet</h4>
  <pre>
DECLARE
   CURSOR c_alumnes IS
     SELECT nom, edat FROM alumnes;
   
   v_nom alumnes.nom%TYPE;
   v_edat alumnes.edat%TYPE;
BEGIN
   OPEN c_alumnes;
   LOOP
      FETCH c_alumnes INTO v_nom, v_edat;
      EXIT WHEN c_alumnes%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('Nom: ' || v_nom || ' - Edat: ' || v_edat);
   END LOOP;
   CLOSE c_alumnes;
END;
  </pre>

  <hr>

  <h3> Cursor FOR ‚Äì simplificat</h3>
  <p>Oracle gestiona autom√†ticament l‚Äôobertura, lectura i tancament.</p>
  <pre>
BEGIN
   FOR reg IN (SELECT nom, edat FROM alumnes) LOOP
      DBMS_OUTPUT.PUT_LINE('Nom: ' || reg.nom || ', Edat: ' || reg.edat);
   END LOOP;
END;
  </pre>

  <h3> Cursors amb par√†metres</h3>
  <pre>
DECLARE
   CURSOR c_per_edat(min_edat NUMBER) IS
     SELECT nom FROM alumnes WHERE edat > min_edat;

   v_nom alumnes.nom%TYPE;
BEGIN
   OPEN c_per_edat(18);
   LOOP
      FETCH c_per_edat INTO v_nom;
      EXIT WHEN c_per_edat%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('Major de 18: ' || v_nom);
   END LOOP;
   CLOSE c_per_edat;
END;
  </pre>

  <hr>



  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Sempre tanca els cursors despr√©s d‚Äôusar-los</li>
    <li> Utilitza <strong>FOR cursors</strong> si nom√©s necessites llegir</li>
    <li> Evita FETCHs sense <code>EXIT WHEN %NOTFOUND</code></li>
    <li> Reutilitza variables amb tipus %TYPE o %ROWTYPE</li>
  </ul>

  <h3>üìò Consulta de cursors actius</h3>
  <p>(per sessions de treball, administradors)</p>
  <pre>
SELECT * FROM v$open_cursor
WHERE user_name = 'NOM_USUARI';
  </pre>
</section>



<section id="excepcions">
  <h2>Gesti√≥ d‚ÄôExcepcions en PL/SQL</h2>

  <h3>üìò Qu√® √©s una excepci√≥?</h3>
  <p>
    Una <strong>excepci√≥</strong> √©s una situaci√≥ d‚Äôerror que es produeix durant l‚Äôexecuci√≥ d‚Äôun bloc PL/SQL.
    Oracle permet capturar aquestes situacions per gestionar-les de manera controlada i evitar que el bloc falli de manera abrupta.
  </p>

  <h3> Estructura general amb excepcions</h3>
  <pre>
BEGIN
   -- codi normal
EXCEPTION
   WHEN tipus_excepcio THEN
      -- codi d'error
END;
  </pre>

  <h3> Tipus d‚Äôexcepcions</h3>

  <h4> Excepcions predefinides</h4>
  <p>Oracle les reconeix autom√†ticament. Exemple:</p>
  <ul>
    <li><code>NO_DATA_FOUND</code> ‚Üí no hi ha resultats</li>
    <li><code>TOO_MANY_ROWS</code> ‚Üí SELECT retorna m√©s d‚Äôuna fila</li>
    <li><code>ZERO_DIVIDE</code> ‚Üí divisi√≥ per zero</li>
  </ul>

  <h4> Exemple</h4>
  <pre>
DECLARE
   v_nom alumnes.nom%TYPE;
BEGIN
   SELECT nom INTO v_nom FROM alumnes WHERE id = 999;
   DBMS_OUTPUT.PUT_LINE(v_nom);
EXCEPTION
   WHEN NO_DATA_FOUND THEN
      DBMS_OUTPUT.PUT_LINE('Cap alumne amb aquest ID');
END;
  </pre>

  <h4> Excepcions no predefinides</h4>
  <p>Oracle les pot capturar amb <code>SQLCODE</code> i <code>SQLERRM</code>:</p>
  <pre>
BEGIN
   -- operaci√≥ que pot fallar
EXCEPTION
   WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error ' || SQLCODE || ': ' || SQLERRM);
END;
  </pre>

  <h4>üîß Excepcions personalitzades</h4>
  <p>Es poden declarar amb <code>EXCEPTION</code> i cridar amb <code>RAISE</code>:</p>
  <pre>
DECLARE
   ex_preu_invalid EXCEPTION;
   v_preu NUMBER := -5;
BEGIN
   IF v_preu < 0 THEN
      RAISE ex_preu_invalid;
   END IF;
EXCEPTION
   WHEN ex_preu_invalid THEN
      DBMS_OUTPUT.PUT_LINE('Error: preu negatiu no v√†lid');
END;
  </pre>

  <h3> Claus d‚Äô√∫s</h3>
  <ul>
    <li><code>RAISE</code> ‚Üí provoca una excepci√≥</li>
    <li><code>WHEN ... THEN</code> ‚Üí captura una excepci√≥</li>
    <li><code>WHEN OTHERS THEN</code> ‚Üí captura qualsevol error no gestionat abans</li>
    <li><code>SQLERRM</code> ‚Üí mostra el missatge d‚Äôerror</li>
    <li><code>SQLCODE</code> ‚Üí mostra el codi num√®ric de l‚Äôerror</li>
  </ul>

  <h3>üß† Exemple final combinat</h3>
  <pre>
DECLARE
   v_total NUMBER := 0;
BEGIN
   v_total := 100 / 0;
EXCEPTION
   WHEN ZERO_DIVIDE THEN
      DBMS_OUTPUT.PUT_LINE('No es pot dividir per zero!');
   WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error inesperat: ' || SQLERRM);
END;
  </pre>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Captura errors espec√≠fics abans de fer servir <code>OTHERS</code></li>
    <li> Informa l‚Äôusuari o registra l‚Äôerror</li>
    <li> No capturis <code>OTHERS</code> sense mostrar cap missatge (silenciar errors √©s perill√≥s)</li>
    <li> Fes servir excepcions personalitzades quan tinguis validacions pr√≤pies</li>
  </ul>
</section>





<section id="tasques">
  <h2> Tasques automatitzables en Oracle</h2>

  <h3> Qu√® podem automatitzar?</h3>
  <p>En un entorn Oracle, √©s habitual automatitzar tasques per millorar la gesti√≥ i el rendiment del sistema. Algunes de les tasques m√©s comunes s√≥n:</p>
  <ul>
    <li> Exportacions i c√≤pies de seguretat</li>
    <li> Importacions de dades</li>
    <li> Execuci√≥ d'informes</li>
    <li> Neteja de logs i arxius antics</li>
    <li> Tasques de manteniment peri√≤dic</li>
  </ul>

  <h3>üìÑ Scripts SQL i .bat</h3>
  <p>Pots crear scripts `.sql` amb comandes Oracle i executar-los des de scripts `.bat` o `.sh` mitjan√ßant <code>sqlplus</code>.</p>

  <h4> Exemple: script SQL</h4>
  <pre>
-- arxiu: informe.sql
SET ECHO OFF
SET FEEDBACK OFF
SPOOL informe_resultats.txt

SELECT * FROM alumnes;

SPOOL OFF
EXIT;
  </pre>

  <h4> üñ•Ô∏è Script .bat (Windows)</h4>
  <pre>
-- arxiu: llan√ßa_informe.bat
sqlplus usuari/contrasenya@XE @informe.sql
pause
  </pre>

  <h4>üêß Script .sh (Linux)</h4>
  <pre>
#!/bin/bash
sqlplus usuari/contrasenya@XE @informe.sql
  </pre>

  <h3>üìÜ Oracle SCHEDULER  -  JOBS </h3>
  <p>
    Oracle incorpora un sistema per programar tasques directament des de la base de dades: <strong>DBMS_SCHEDULER</strong>.
  </p>
  <h4> Donar perm√≠s</h4>
  <pre>
  --  Un usuari necessita tindre perm√≠s per crear jobs (treballs) i executar-los !!
  grant create job to usuari;
  grant execute on dbms_scheduler to usuario;    
  </pre>

  <h4> Crear una tasca programada</h4>
  <pre>
BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
    job_name        => 'JOB_INFORME',
    job_type        => 'PLSQL_BLOCK',
    job_action      => 'BEGIN informe_alumnes(); END;',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY; BYHOUR=8',
    enabled         => TRUE
  );
END;
  </pre>

  <h4> Modificar una tasca programada</h4>
  <pre>
BEGIN
  dbms_scheduler.set_attribute_null( name=>‚Äônom‚Äô, attribute=>‚Äôa‚Äô);
  dbms_scheduler.set_attribute(name=>‚Äônom‚Äô,attribute=>‚Äôa‚Äô,value=>‚Äôv‚Äô);
END;   </pre>  

<h4> Par√†metre  <code>repeat_interval</code> </h4>
<pre>
  FREQ=MONTHLY ‚Üí S'executa un cop al mes. (Defineix la repetici√≥ mensual)
  BYMONTHDAY=1 El dia 1 de cada mes
  BYDAY=TU ‚Üí Els dimarts.
  BYSETPOS=1 ‚Üí Nom√©s el primer dimarts del mes.
  BYHOUR=1; BYMINUTE=5 ‚Üí A la 01:05 AM.  
</pre>
<p>FREQ={SECONDLY | MINUTELY | HOURLY | DAILY | WEEKLY | MONTHLY | YEARLY};
  A partir d‚Äôaqu√≠, pots afegir modificadors com BYSECOND, BYMINUTE, BYHOUR, BYDAY, BYMONTH, etc</p>

<h4>Exemples d'√∫s del par√†metre</h4>
<pre>
  Cada dia a les 8:30 AM
  REPEAT_INTERVAL => 'FREQ=DAILY; BYHOUR=8; BYMINUTE=30;'
  Cada dilluns i dimecres a les 10:00 AM i 4:00 PM
  REPEAT_INTERVAL => 'FREQ=WEEKLY; BYDAY=MON,WED; BYHOUR=10,16; BYMINUTE=0;'
  El primer dimarts de cada mes a les 09:00 AM
  REPEAT_INTERVAL => 'FREQ=MONTHLY; BYDAY=TU; BYSETPOS=1; BYHOUR=9; BYMINUTE=0;'
  L'√∫ltim divendres de cada mes a les 18:00
  REPEAT_INTERVAL => 'FREQ=MONTHLY; BYDAY=FR; BYSETPOS=-1; BYHOUR=18; BYMINUTE=0;'
  Cada 6 hores
  REPEAT_INTERVAL => 'FREQ=HOURLY; INTERVAL=6;' </pre>


  <h4>üîç Consultar jobs</h4>
  <pre>
SELECT job_name, state FROM user_scheduler_jobs;    </pre>

  <h4> Aturar o eliminar un job</h4>
  <pre>
BEGIN
  DBMS_SCHEDULER.DISABLE('JOB_INFORME');
  DBMS_SCHEDULER.DROP_JOB('JOB_INFORME');
END;   </pre>

  <h3> Triggers de sistema (a nivell de sessi√≥)</h3>
  <p>Tamb√© pots utilitzar <strong>triggers de sistema</strong> per executar codi quan es produeixen accions espec√≠fiques:</p>
  <pre>
CREATE OR REPLACE TRIGGER t_inici_sessio
AFTER LOGON ON DATABASE
BEGIN
  INSERT INTO log_sessio(usuario, data)   VALUES (USER, SYSDATE); 
END;   </pre>

  <h3> Exemple complet d‚Äôautomatitzaci√≥</h3>
  <ul>
    <li> <code>informe.sql</code>: genera un informe amb SELECTs</li>
    <li> <code>informe.bat</code>: l‚Äôexecuta des del sistema</li>
    <li> <strong>DBMS_SCHEDULER</strong>: programa la seva execuci√≥ cada dia a les 8h</li>
  </ul>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Guarda scripts en carpetes versionades (ex: GIT)</li>
    <li> Documenta les tasques automatitzades</li>
    <li> Revisa els permisos dels usuaris que executen les tasques</li>
    <li>‚ö†Ô∏è Evita duplicar jobs o crear-ne de recurrents sense control</li>
  </ul>

  <h3> SQL din√†mic</h3>
  <p>En algunes tasques de manteniment, s‚Äôutilitzar√† el diccionari de dades 
    (amb un cursor)- i per a cada objecte de DD s‚Äôaplicar√† una sent√®ncia DDL</p>
    <p>Si esta sent√®ncia correspon al DDL, no es pot executar directament dins d'un bloc de codi</p>
    <p>En este cas, es far√† √∫s de la sent√®ncia <code>execute immediate</code></p>
    <p><code>execute immediate</code> √©s una instrucci√≥ de PL/SQL que permet executar sent√®ncies SQL din√†miques
       √©s a dir, sent√®ncies constru√Ødes en temps d'execuci√≥ com cadenes de text.</p>
    <p>Exemple</p>
<pre>
  create procedure defrag_taules (vuser varchar2(20))
  -- Este proc desfragmenta totes les taules d‚Äôun usuari/schema
  as
  cursor c is select table_name,tablespace_name
  from dba_tables where user=vuser ;
  begin
  for x in c loop
    execute immediate ('alter table ' || x.table_name || ' move');
    dbms_output.put_line('Taula desfragmentada:' || x.table_name);
    end loop;
  end;  
</pre>


</section>


<section id="altres-recursos">
  <h2>Altres recursos</h2>
    <h3>√ös de Dates en Oracle</h3>
       <a href="">link</a> 
    <h3>AuithID en procedure</h3>

    <h3>FOR en procedure</h3>


</section>


</main>

<script>

  // Per poder copiar codi en el porta-retalls. S'ha de posar un bot√≥ en cada <pre>
      //  <div class="pre-container">
      //    <button class="copy-button">Copia Codi !</button>
  document.addEventListener('DOMContentLoaded', function () {
    const buttons = document.querySelectorAll('.copy-button');

    buttons.forEach(button => {
      button.addEventListener('click', function () {
        const code = this.nextElementSibling.innerText;
        navigator.clipboard.writeText(code).then(() => {
          this.innerText = ' ‚úî Copiat!';
          setTimeout(() => this.innerText = 'Copia Codi !', 3000);
        });
      });
    });
  });

</script>

</body>
</html>
