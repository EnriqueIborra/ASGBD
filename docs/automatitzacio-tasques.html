<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>üìù Automatitzaci√≥ Oracle</title>
  <link rel="stylesheet" href="estilsunitats.css">
  <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css" />
</head>
<body>

<header>
  <a href="index.html">
      <!--<img src="https://upload.wikimedia.org/wikipedia/commons/5/50/Oracle_logo.svg" alt="Oracle Logo"> -->
      <img src="imgs/ASGBD.png" alt="M√≤dul ASGBD">
  </a>
  <h1>ASGBD   -    Automatitzaci√≥ de tasques en Oracle</h1>
</header>

<nav>
  <h3>√çndex</h3>
  <a href="#autom">Automatitzaci√≥: Conceptes</a>
  <a href="#blocs">Blocs an√≤nims</a>
  <a href="#editor-bloc-anonim">Editor codi online</a>
  <a href="#variables">Variables</a>
  <a href="#estructures">Estructures de programaci√≥</a>
  <a href="#proc-func">Procediments-funcions</a>
  <a href="#procediments">Procediments en ORACLE</a>
  <a href="#funcions">Funcions en ORACLE</a>
  <a href="#disparadors">Disparadors en ORACLE</a>
  <a href="#seq">Seq√º√®ncies</a>
  <a href="#cursors">Cursors</a>
  <a href="#excepcions">Excepcions</a>
  <a href="#tasques">Tasques automatitzables</a>
  <a href="#altres-recursos">Altres Recursos</a>
</nav>

<main>

  <section id="autom">
    <br><h2> Automatitzaci√≥</h2>
    <p>L'automatitzaci√≥ consisteix en fer tasques de manera sistem√†tica i repetitiva 
      sense que estiga involucrat un usuari en la seua execuci√≥</p>
    <p>Quan parlem d‚Äôautomatitzaci√≥ en Oracle, generalment ens referim a processos que es programen per executar-se autom√†ticament, 
      sense necessitat d‚Äôintervenci√≥ manual. Oracle ofereix diverses eines i m√®todes per fer aix√≤</p>
    <h3>Avantatges Automatitzaci√≥</h3>
      <ul>
        <li>Estalvi de temps</li>
        <li>Reducci√≥ costos administraci√≥</li>
        <li>Reducci√≥ errors ( hum√†)</li>
      </ul>

      <h3>Tipus</h3>
      <ul>
        <li>Programa extern (al SGBD)</li>
        <ul><li> Programador de Tasques de Windows, Crontab en Linux, etc..</li></ul>
        <li>Programa intern : rutina de bbdd + job</li>
      </ul>

      <h3>Rutina</h3>
      <ul>
        <li>Script, gui√≥, programa o seq√º√®ncia de comandos que permeten dur a terme el processament d'unes certes accions</li>
        <li>Quan √©s creada rep un nom que permet que siga invocada tantes vegades com siga necessari</li>
        <li>Van ser introdu√Ødes en la versi√≥ SQL3, o SQL:1999</li>
      </ul>
      <p>Els guions o scripts donaren pas al PL/SQL ( que √©s diferent del SQL )</p>
      <p><strong>SQL</strong> (Structured Query Language) √©s un llenguatge declaratiu. S‚Äôutilitza per gestionar i consultar bases de dades. 
        No t√© estructures de control com bucles o condicions complexes. SELECT (consultar dades), 
INSERT (inserir dades), UPDATE (actualitzar dades), DELETE (esborrar dades), i altres com DDL, DCL, TCL    </p>
        <p><strong>PL/SQL</strong> (Procedural Language / SQL). √âs una extensi√≥ de SQL creada per Oracle. √âs un llenguatge procedimental.
Permet utilitzar:  Variables, Condicions (IF), Bucles (LOOP, WHILE, FOR), Procediments i funcions.
S‚Äôutilitza per crear programs dins de la base de dades.</p>

      <h3>El SGBD deu proporcionar:</h3>
      <ul>
        <li>Eines necess√†ries per a crear rutines</li>
        <li>Eines per a executar les rutines autom√†ticament</li>
      </ul>
 
      <h3>Avantatges rutina interna</h3>
      <ul>
        <li>Rendiment</li>
        <li>Reutilitzaci√≥ de codi</li>
        <li>Encapsula regles de negoci</li>
        <li>Major seguretat</li>
      </ul>
      
      <img src="imgs/important.png" class="imatge-dreta"  alt="stop" style="width: 15%">
      <h2>Les rutines: S‚Äôhan de Documentar</h2>
      
      <h2>QUE ??</h2><p>Descripci√≥ de la tasca, descripci√≥ de par√†metres d‚Äôentrada i eixida, Autor, Versi√≥, Data d‚Äô√∫ltima modificaci√≥, etc..</p>
      <h2>COM ??</h2> <p>** Fent servir comentaris en el codi de les rutines. Amb /* */ o  --</p>
      <pre>-- Esto es un comentario </pre>
      <p>** Fent servir documentaci√≥ institucional en qualsevol suport (documents, fulls de c√†lcul, diagrames,etc..)</p>
       
  </section>



  <section id="blocs">
    <br>
    <h2>üßæ Bloc An√≤nim en PL/SQL</h2>
  
    <h3> Qu√® √©s un bloc an√≤nim?</h3>
    <p>
      Un <strong>bloc an√≤nim</strong> √©s una unitat de codi en PL/SQL que:
    </p>
    <ul>
      <li> No t√© nom ni es guarda a la base de dades.</li>
      <li> S‚Äôexecuta directament des de la pestanya. Es pot guardar en un fitxer extern i despr√©s recuperar.</li>
      <li> √âs ideal per a proves o per a executar operacions puntuals.</li>
      <li> Pot incloure sent√®ncies SQL, declaracions de variables, control de flux, i gesti√≥ d‚Äôexcepcions.</li>
    </ul>
     <hr>
    <h4>En sqlplus es pot:</h4>
    <ul>
      <li>Es pot editar el contingut del buffer amb  <code>edit</code></li>
      <li>Es pot executar el contingut del buffer amb  <code>run  o  /</code></li>
      <li>Guardar el contingut del buffer en un arxiu ( posa nom + .sql )</li>
      <ul>
        <li>SQL> SAVE nom_fitxer.sql</li>
        <li>SQL> SAVE nom_fitxer.sql REPLACE</li>
      </ul>
      <li>Carrega el contingut d'un fitxer en el buffer (per√≤ l'executa)</li>
      <p>SQL> GET nom_fitxer.sql</p>
      <li>Executa el contingut d'un fitxer</li>
      <ul>
        <li>SQL> @prova.sql</li>
        <li>SQL> @/ruta/completa/prova.sql</li>
        <li>SQL> START prova.sql</li>
      </ul>
    </ul>

    <h4>En SQL Developer</h4>
    <p>Es treballa amb WorkSheets (pestanya oberta). Cada pestanya √©s una connexi√≥</p>
    <p>Per executar una linia del WorkSheet, prem  Ctrl+Enter</p>
    <p>Per executar TOTES les linies, prem F5</p>
    <p>Per guardar el contingunt del WorkSeet, Ves a File ‚Üí Save o Save As‚Ä¶ </p>
    <p>Per recuperar el text guardat en una fitxer, File ‚Üí Open ‚Üí  prova_bloc.sql</p>
    <p>Per executar el contingut d'un fitxer directament => @/ruta/prova_bloc.sql  i prem F5  </p>
     <hr>
    <h3> Estructura b√†sica d‚Äôun bloc an√≤nim</h3>
    <p>El primer √©s activar l'eixida per pantalla. Esta sent√®ncia es pot executar una vegada al principi</p>
    <pre translate="no">SET SERVEROUTPUT ON;</pre>
    <pre translate="no">DECLARE
    vNom VARCHAR2(20) := '&nom';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Hola ' || vNom);
    DBMS_OUTPUT.PUT_LINE('Benvingut a la programaci√≥ en PL/SQL');
END;
.  -- Nom√©s en SQL*Plus!      </pre>
 
    <p>
      ‚ö†Ô∏è En <strong>SQL*Plus</strong> s‚Äôha de posar un punt (<code>.</code>) al final per enviar-lo al buffer i despr√©s executar-lo amb <code>RUN</code>.  
      En <strong>SQL Developer</strong>, s‚Äôexecuta amb <kbd>F5</kbd> i <strong>no cal posar el punt</strong>.
    </p>
  
    <h3>üí¨ Explicaci√≥ pas a pas</h3>
    <ul>
      <li><code>DECLARE</code>: bloc <strong>opcional</strong> per declarar variables.</li>
      <li><code> <strong>&</strong>nom</code>: Variable de substituci√≥.(Es mostrar√† al demanar el valor)</li>
      <li><code>BEGIN</code>: bloc obligatori per executar codi.</li>
      <li><code>DBMS_OUTPUT.PUT_LINE</code>: mostra text a pantalla (cal tenir activat <code>SET SERVEROUTPUT ON</code>).</li>
      <li><code>END;</code>  finalitza el bloc.</li>
      <li><code><strong>.</strong></code>  (nom√©s en SQL*Plus) envia el bloc al buffer per executar-lo.</li>
    </ul>
  <p><strong>&nom</strong> Una variable de substituci√≥ √©s una variable que s'utilitza principalment en eines com SQL*Plus, SQL Developer o Toad, per a permetre que l‚Äôusuari introdu√Øsca un valor en temps d‚Äôexecuci√≥, abans que s'execute un bloc PL/SQL o una sent√®ncia SQL.
    No √©s part del llenguatge PL/SQL com a tal, sin√≥ una funcionalitat d‚Äôaquestes eines per fer scripts m√©s din√†mics i interactius.</p>
    <p>S'usar√†  <strong>'&NOM'</strong> amb cometes per demanar un STRING i <strong>&NOM</strong> sense cometes per demanar un NUMBER</p>
    <p><strong>PUT_LINE</strong> √âs un procediment del paquet <strong>DBMS_OUTPUT</strong> d'ORACLE.</p>
    <p><strong>PUT_LINE</strong> avalua !!  i imprimeix el resultat.</p>
    <pre>
  DBMS_OUTPUT.PUT_LINE('La data actual √©s: '); -- una cadena
  DBMS_OUTPUT.PUT_LINE(  vdata  );             -- una variable (el contenido)
  DBMS_OUTPUT.PUT_LINE(  'vdata'  );           -- una cadena
  DBMS_OUTPUT.PUT_LINE(  sysdate );            --  resultado de una funcion
  DBMS_OUTPUT.PUT_LINE('La data actual √©s: ' ||  sysdate);  -- una concatenaci√≥n
  DBMS_OUTPUT.PUT_LINE(  3*4+5**2+1 );              --  un c√°lculo matem√°tico
  DBMS_OUTPUT.PUT_LINE(  3*4+5**2+1 || '  456');    --  un casting  !!
        </pre>

    <h3> Exemple senzill</h3>
    <pre translate="no">
  SET SERVEROUTPUT ON;
  
  DECLARE
     vData DATE := SYSDATE;
  BEGIN
     DBMS_OUTPUT.PUT_LINE('La data actual √©s: ' ||  vData  );
     DBMS_OUTPUT.PUT_LINE('La data actual √©s: ' || TO_CHAR(vData, 'DD/MM/YYYY'));
  END;
    </pre>
    <p>PL/SQL no √©s case-sensitive en general. Paraules clau, noms de variables, procediments i funcions no distingueixen entre maj√∫scules i min√∫scules.
      ‚ùó‚ùó Per√≤, els valors dels strings o de camps VARCHAR, S√ç que distingeixen. </p>
    <p><strong>SYSDATE</strong> √©s una <strong>funci√≥</strong> d'ORACLE que torna la data/hora de l'instant actual</p>
    <p><strong>TO_CHAR</strong> √©s una <strong>funci√≥</strong> d'ORACLE que transforma de format DATA a format VARCHAR2 </p>
  
    <h3> Bones pr√†ctiques</h3>
    <ul>
      <li> Documenta el codi amb comentaris (<code>--</code> per una l√≠nia, <code>/* */</code> per m√∫ltiples).</li>
      <li> Fes servir blocs an√≤nims per a provar procediments o funcions abans de guardar-los.</li>
      <li> Prova condicions, bucles i excepcions dins blocs an√≤nims abans d'incorporar-ho a rutines emmagatzemades.</li>
    </ul>
  
    <h3> Ordres √∫tils en SQL*Plus</h3>
    <ul> Els comandos b√†sics d'sqlplus no necessiten posar un ";" al final. No s√≥n comandos SQL, s√≥n propis de l'sqlplus
      <li><code>EDIT</code> ‚Üí edita l‚Äôscript actual</li>
      <li><code>LIST</code> ‚Üí mostra el contingut del buffer</li>
      <li><code>RUN</code> ‚Üí executa el bloc en el buffer (tamb√©  r  o  /)</li>
      <li><code>SAVE fitxer.sql</code> ‚Üí desa l‚Äôscript en un fitxer</li>
      <li><code>GET fitxer.sql</code> ‚Üí carrega un script des d'un fitxer</li>      
      <li><code>start fitxer.sql</code> ‚Üí carrega i executa un script des d'un fitxer</li>      
      <li><code>@fitxer.sql</code> ‚Üí equival a start</li>
    </ul>
    <a href="https://www.codifica.me/sql-plus/"> .. üìò Es pot ampliar amb *Tutorial d' sql*plus .. </a>
  
    <h3> Ordres √∫tils en SQL Developer</h3>
    <ul>
      <li><strong><code>F5</code></strong> ‚Üí executa l'script de la sessi√≥ activa. Mostra el resultat en l‚Äô√†rea de Script Output.</li>
      <li><strong><code>F9</code></strong> ‚Üí executa sent√®ncia (una,, on est√† el cursor). Mostra el resultat en l‚Äô√†rea de Resultats.</li>
      <li>Ctrl+Intro  ‚Üí Equivalent a F9</li>
      <li><code>.</code> ‚Üí En SQL Developer no cal posar un punt al final</li>
      <li>Recorda posar <code>SET SERVEROUTPUT ON;</code> abans del bloc an√≤nim</li>
      
    </ul>


    <h3> Difer√®ncia amb procediments</h3>
    <p>Els blocs an√≤nims no es poden reutilitzar directament, ja que no tenen nom. (Si es poden guardar en un fitxer extern, i despres recuperar (obrir), i tornar a executar).
      Per a reutilitzar codi, millor usar procediments o funcions.</p>
  
    <h3>üß™ Prova-ho!</h3>
    <p>
      Prova aquest bloc en <strong>SQL Developer</strong>:
    </p>
    <pre>
  DECLARE
     vNom VARCHAR2(20) := 'Ada';
  BEGIN
     DBMS_OUTPUT.PUT_LINE('Hola ' || vNom || '! Bon dia!');
  END;
    </pre>
    <p>Executa el bloc algunes vegades, i despr√©s guarda-lo en un fitxer extern</p>
  </section>
  
  
  <section id="editor-bloc-anonim">
    <h2>üß™ Pr√†ctica interactiva: Bloc An√≤nim</h2>
    <p>
      Prova aqu√≠ mateix la sintaxi d‚Äôun bloc an√≤nim PL/SQL. Es la p√†gina oficial de ORACLE.
    </p>

    <a href="https://livesql.oracle.com/landing/">Simulador de codi de ORACLE</a>

  </section>

  <section id="variables">
    <h2> üóÉÔ∏è Comentaris, Variables i Operacions en PL/SQL</h2>
    <h2>Comentaris</h2>
    <p>L'√πs de comentaris √©s un recurs per poder documentar el codi. Com s'ha dit abans, √©s molt importat documentar el codi</p>
    <pre>
      --  En dos guionets es posa un comentari d'una l√≠nia.
      /*  En la barra i l'asterisc es pot
          posar comentaris de m√©s d'una l√≠nia
      */
    </pre>

    <h2>Variables</h2>
   
      <p>Una <strong>variable</strong> en PL/SQL √©s un espai de mem√≤ria per emmagatzemar dades temporals durant l'execuci√≥ d‚Äôun bloc de codi. Pot contindre textos, n√∫meros, dates, etc.</p>
      <p>En PL/SQL (Oracle), les variables s‚Äôhan de declarar <strong>sempre</strong> abans d‚Äôutilitzar-les. Les variables 
        es declaren a la secci√≥ DECLARE (o a la part de declaraci√≥ d‚Äôun procediment, funci√≥ o paquet).</p>
      <h4> Estructura b√†sica</h4>
      <pre><code>DECLARE
    nom_variable tipus ;                    -- Es declara per√≤ no s'inicialitza. Pren el valor NULL   
    nom_variable tipus [:= valor_inicial];  -- Es declara i s'inicialitza amb un valor  
    nom_variable tipus [DEFAULT valor_inicial];  -- DEFAULT √©s equivalent a  :=
BEGIN
    -- √∫s de la variable
END; </code></pre>
    
      <h4> Tipus b√†sics</h4>
      <table>
        <tr>
          <th>Tipus</th>
          <th>Descripci√≥</th>
          <th>Exemple</th>
        </tr>
        <tr>
          <td><code>VARCHAR2(n)</code></td>
          <td>Cadena de text de longitud variable</td>
          <td>'Hola', 'Joan'</td>
        </tr>
        <tr>
          <td><code>NUMBER(p,s)<br>NUMBER(p)<br>NUMBER</code></td>
          <td>N√∫meros amb precisi√≥ i escala</td>
          <td>123, 45.67</td>
        </tr>
        <tr>
          <td><code>DATE</code></td>
          <td>Data i hora</td>
          <td>SYSDATE</td>
        </tr>
        <tr>
          <td><code>BOOLEAN</code></td>
          <td>TRUE, FALSE, NULL (nom√©s PL/SQL)</td>
          <td>TRUE</td>
        </tr>
        <tr>
          <td><code>%TYPE</code></td>
          <td>Tipus igual al d‚Äôuna columna o una altra variable</td>
          <td>taula.columna%TYPE</td>
        </tr>
      </table>
    
      <h4>üß™ Exemple de declaraci√≥</h4>
      <pre><code>DECLARE
    v_nom       VARCHAR2(50) := 'Anna';
    v_edat      NUMBER := 30;
    v_sou       NUMBER(8,2);
    v_data_naix DATE := TO_DATE('1995-06-10', 'YYYY-MM-DD');
    v_es_actiu  BOOLEAN := TRUE;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Nom: ' || v_nom);
    DBMS_OUTPUT.PUT_LINE('Edat: ' || v_edat);
END; </code></pre>
    
      <h4> Variables amb <code>%TYPE</code></h4>
      <pre><code>DECLARE
    v_nom_client clients.nom%TYPE;
BEGIN
    SELECT nom INTO v_nom_client FROM clients WHERE id = 1;
    DBMS_OUTPUT.PUT_LINE('Client: ' || v_nom_client);
END; </code></pre>
    
      <h4>üõ†Ô∏è Com assignar valors</h4>
        <h3>-- En el bloc DECLARE</h3>
      <ul> 
        <li><strong>Entrada de l‚Äôusuari (SQL Developer):</strong> <pre><code>v_nom := '&amp;nom_usuari';</code>  -- Variable de substituci√≥
<code>/*  una variable de substituci√≥ √©s un valor que s‚Äôintrodueix en temps d‚Äôexecuci√≥
   i que Oracle substitueix abans d‚Äôexecutar la sent√®ncia */</code></pre></li>
        
        <li>Utilitzant el <strong> DEFAULT</strong> <pre> v_code number default 100;</pre></li>
      </ul>
        <h3>-- En el bloc principal BEGIN</h3>
      <ul> 
        <li><strong>Assignaci√≥ directa:</strong> <code>v_edat := 25;</code></li>
        <li><strong>Amb SELECT INTO:</strong>
          <pre><code>SELECT sou INTO v_sou FROM empleats WHERE id = 5;
            o 
SELECT avg(sou) INTO v_mitjanasou FROM empleats WHERE departament=101;            
          </code></pre>
        </li>
        
      </ul>
    
      <h4>‚ùó Detalls importants</h4>
      <ul>
        <li>Les variables nom√©s existeixen dins del bloc on es declaren.</li>
        <li>No pots fer <code>SELECT ...</code> sense <code>INTO</code> dins de PL/SQL.</li>
        <li><code>BOOLEAN</code> nom√©s es pot usar dins de PL/SQL, no en SQL est√†ndard. (‚ùó s√≠ en oracle23 ‚ùó)</li>
      </ul>
  

    <h2>Operacions</h2>
      <h3> Operacions amb Variables en PL/SQL</h3>
    
      <p>Una vegada declarades, les variables en PL/SQL poden utilitzar-se per fer c√†lculs, tractament de text, dates i l√≤gica condicional. Ac√≠ tens exemples clars i √∫tils:</p>
    
      <h3>üìê 1. Operacions aritm√®tiques</h3>
      <p>Per fer sumes, restes, multiplicacions, divisions i pot√®ncies amb variables de tipus <code>NUMBER</code>:</p>
      <pre><code>DECLARE
    a NUMBER := 10;
    b NUMBER := 3;
    resultat NUMBER;
BEGIN
    resultat := a + b;
    DBMS_OUTPUT.PUT_LINE('Suma: ' || resultat);

    resultat := a - b;
    DBMS_OUTPUT.PUT_LINE('Resta: ' || resultat);

    resultat := a * b;
    DBMS_OUTPUT.PUT_LINE('Multiplicaci√≥: ' || resultat);

    resultat := a / b;
    DBMS_OUTPUT.PUT_LINE('Divisi√≥: ' || resultat);

    resultat := a ** b;
    DBMS_OUTPUT.PUT_LINE('Pot√®ncia: ' || resultat);
END; </code></pre>
<p><strong>Preced√®ncia</strong>: No s'ha d'oblidar que no √©s el mateix 2 + 5 * 3  que  (2 + 5) * 3. La preced√®ncia o ordre de les operacions √©s crucial en el resultat</p>
<p>En PL/SQL este ordre √©s el seg√ºent:  
<table><tr> <td>( )</td>  <td>unaris</td> <td>** pot√®ncia</td>  <td>* , /, mod</td> <td>+ i -</td> 
  <td>comparaci√≥</td> <td>l√≤gics (NOT AND OR)</td></tr></table>

I els operadors l√≤gics tenen preced√®ncia entre ells. NOT t√© m√©s preced√®ncia que AND i AND m√©s que OR, </p>
<p>Encara que conegues la preced√®ncia, usa par√®ntesis per fer el codi: *m√©s clar, *menys propens a errors, *m√©s llegible per altres desenvolupadors</p>
<p>Altres operacions aritm√®tiques amb funcions: ABS, ROUND, TRUNC, MOD, CEIL, FLOOR, SQRT, TO_CHAR </p>
    
      <hr><h3>üî§ 2. Operacions amb cadenes de text</h3>
      <p>Les cadenes (<code>VARCHAR2</code>) es concatenen amb <code>||</code>  </p>
      <pre><code>DECLARE
    nom VARCHAR2(20) := 'Joan';
    cognom VARCHAR2(20) := 'Garcia';
    nom_complet VARCHAR2(50);
BEGIN
    nom_complet := nom || ' ' || cognom;
    DBMS_OUTPUT.PUT_LINE('Nom complet: ' || nom_complet);
END; </code></pre>
<p>Altres operacions amb funcions: LENGTH, UPPER, LOWER, INITCAT, SUBSTR, INSTR, REPLACE, TRIM, LTRIM, RTRIM, TO_NUMBER</p>
    
      <hr><h3>üìÖ 3. Operacions amb dates</h3>
      <p>Les dates es poden restar o sumar, on 1 unitat √©s 1 dia: <br> 
      <code>(i on per exemple, un  1.5 ser√† un dia i mig, es a dir 1 dia i 12 hores)</code></p>
      <pre><code>DECLARE
    data_naix DATE := TO_DATE('2000-01-01', 'YYYY-MM-DD');
    avui      DATE := SYSDATE;
    edat_dies NUMBER;
BEGIN
    edat_dies := avui - data_naix;
    DBMS_OUTPUT.PUT_LINE('Dies des de naixement: ' || edat_dies);

    DBMS_OUTPUT.PUT_LINE('Dem√† ser√†: ' || (avui + 1));
END; </code></pre>
    <p>Al igual que TO_DATE, est√† el TO_CHAR, amb la posibilitat d'usar m√†scara ('DD/MM/YY HH:MI PM')</p>
    <p class="tips"> ‚úîÔ∏è El tipus "DATE" pot emmagatzemar fins al minut i el segon. (Exemple d'un valor de tipus DATE: 23-MAI-2025 14:35:22)
       <br> Si es necessita m√©s precisi√≥, es pot utilitzar el tipus "TIMESTAMP", el qual
      pot emmagatzemar fins a milion√®sima de segon (Exemple d'un valor de tipus TIMESTAMP: 23-MAI-2025 14:35:22.123456)
    </p>
    <p class="alert"> S'ha d'anar amb cura en les operacions amb dates, perqu√® tots els mesos no tenen el mateix nombre
      de dies, ni tots els anys tampoc tenen el mateix nombre de dies !! </p>
    
      <hr><h3> 4. Operacions l√≤giques</h3>
      <p>Amb variables <code>BOOLEAN</code>, pots fer condicions:</p>
      <pre><code>DECLARE
    actiu BOOLEAN := TRUE;
    menor BOOLEAN := FALSE;
BEGIN
    IF actiu AND NOT menor THEN
      DBMS_OUTPUT.PUT_LINE('L‚Äôusuari est√† actiu i no √©s menor.');
    END IF;
END; </code></pre>

     <p>Es pot utilitzar variables <code>BOOLEAN</code> o fer comparacions entre nombres, textos o dates amb els operadors seg√ºents:</p>

    <ul>
      <li><code>=</code> igualtat</li>
      <li><code>&lt;&gt;</code> diferent</li>
      <li><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
      <li><code>AND</code>, <code>OR</code>, <code>NOT</code></li>
    </ul>

      <h3>üß™ Exemple 1: comparacions num√®riques</h3>
      <pre><code>DECLARE
  nota NUMBER := 7.5;
BEGIN
  IF nota >= 5 THEN
      DBMS_OUTPUT.PUT_LINE('Aprovat');
  ELSE
      DBMS_OUTPUT.PUT_LINE('Susp√®s');
  END IF;
END; </code></pre>

      <h3>üß™ Exemple 2: condicions m√∫ltiples</h3>
      <pre><code>DECLARE
  edat NUMBER := 16;
  autoritzat BOOLEAN;
BEGIN
  autoritzat := (edat >= 18);
  IF autoritzat THEN
      DBMS_OUTPUT.PUT_LINE('Pot entrar');
  ELSE
      DBMS_OUTPUT.PUT_LINE('Acc√©s denegat');
  END IF;
END; </code></pre>

      <h3>üß™ Exemple 3: combinaci√≥ amb <code>AND</code> i <code>OR</code></h3>
      <pre><code>DECLARE
  edat NUMBER := 20;
  carnet_conduir BOOLEAN := TRUE;
BEGIN
  IF edat >= 18 AND carnet_conduir THEN
      DBMS_OUTPUT.PUT_LINE('Pot conduir legalment');
  ELSE
      DBMS_OUTPUT.PUT_LINE('No pot conduir');
  END IF;
END; </code></pre>

      <h3>üß™ Exemple 4: comparaci√≥ de cadenes</h3>
      <pre><code>DECLARE
  rol VARCHAR2(20) := 'admin';
BEGIN
  IF rol = 'admin' THEN
      DBMS_OUTPUT.PUT_LINE('Acc√©s complet');
  ELSE
      DBMS_OUTPUT.PUT_LINE('Acc√©s limitat');
  END IF;
END; </code></pre>
   
      <h3> 5. Operacions combinades</h3>
      <p>Es pot combinar n√∫meros i textos, per exemple per calcular salaris:</p>
      <pre><code>DECLARE
    nom VARCHAR2(20) := 'Laura';
    hores NUMBER := 5;
    sou_hora NUMBER := 12.5;
    total_sou NUMBER;
BEGIN
    total_sou := hores * sou_hora;
    DBMS_OUTPUT.PUT_LINE(nom || ' cobrar√† ' || total_sou || ' euros.');
END; </code></pre>
    
      <p class="tips">‚ú® Pots provar aquests blocs en Oracle SQL Developer amb <strong>F5</strong> per veure el resultat a <em>DBMS Output</em>.</p>

  </section>



  
  <section id="estructures">
    <h2>üîÅ Estructures de control en PL/SQL</h2>
  
    <p>Les estructures de control s√≥n fonamentals per controlar el flux d'execuci√≥ d‚Äôun bloc de codi PL/SQL. Oracle suporta els seg√ºents :</p>
  
    <h3> Condicionals</h3>
  
    <h4> Estructura IF</h4>
    <pre>IF condicio THEN
    instruccions;
ELSIF altra_condicio THEN
    instruccions;
ELSE
    instruccions;
END IF;     </pre>
  
    <h4> Exemple IF (üß™ Prova-ho!)</h3>
    <pre>SET SERVEROUTPUT ON;

DECLARE
    edat NUMBER := &dismeedat;
BEGIN
    IF edat >= 18 THEN
      DBMS_OUTPUT.PUT_LINE('Ets major d''edat');
    ELSE
      DBMS_OUTPUT.PUT_LINE('Ets menor');
    END IF;
END;    </pre>
    
    <h4> Estructura CASE</h4>
    <pre>CASE expressio
    WHEN valor1 THEN instruccions;
    WHEN valor2 THEN instruccions;
    ELSE instruccions;
END CASE;   </pre>
  
    <h4> Exemple CASE  (üß™ Prova-ho!)</h4>
    <pre>DECLARE
    nota NUMBER := &dismeNota;
BEGIN
    CASE
      WHEN nota >= 9 THEN DBMS_OUTPUT.PUT_LINE('Excel¬∑lent');
      WHEN nota >= 5 THEN DBMS_OUTPUT.PUT_LINE('Aprovat');
      ELSE DBMS_OUTPUT.PUT_LINE('Susp√®s');
    END CASE;
END;   </pre>
  
    <h3>üîÅ Bucles</h3>
  
    <h4>üîÑ LOOP b√†sic (amb sortida manual)</h4>
    <pre>LOOP
    instruccions;
    EXIT WHEN condicio;
END LOOP;     </pre>
  
    <h4> Exemple LOOP (üß™ Prova-ho!)</h4>
    <pre>DECLARE
    i NUMBER := &dismeVoltes;
BEGIN
    LOOP
      DBMS_OUTPUT.PUT_LINE('Iteraci√≥: ' || i);
      i := i + 1;
      EXIT WHEN i > 5;
    END LOOP;
END;     </pre>
  
    <h4> WHILE LOOP</h4>
    <pre>WHILE condicio LOOP
    instruccions;
END LOOP;     </pre>
  
    <h4> Exemple WHILE   (üß™ Prova-ho!)</h4>
    <pre>DECLARE
    i NUMBER := &dismeVoltes;
BEGIN
    WHILE i <= 3 LOOP
      DBMS_OUTPUT.PUT_LINE('Valor: ' || i);
      i := i + 1;
    END LOOP;
END;     </pre>
  
    <h4> FOR LOOP</h4>
    <pre>FOR variable IN inici..final LOOP
    instruccions;
END LOOP;     </pre>
  
    <h4> Exemple FOR</h4>
    <pre>BEGIN
    FOR i IN 1..4 LOOP
      DBMS_OUTPUT.PUT_LINE('Posici√≥: ' || i);
    END LOOP;
END;    </pre>
  
    <h3> Notes addicionals</h3>
    <ul>
      <li><strong>EXIT WHEN</strong> ‚Üí surt d‚Äôun bucle en una condici√≥</li>
      <li><strong>CONTINUE</strong> ‚Üí salta a la seg√ºent iteraci√≥ (a partir de Oracle 11g)</li>
      <li>Els bucles poden ser <strong>niats</strong> i combinen amb IF o CASE</li>
    </ul>
  
    <h3> Bon √∫s d‚Äôestructures</h3>
    <ul>
      <li> Usa `FOR` si saps quantes vegades vols repetir</li>
      <li> Usa `WHILE` si depens d‚Äôuna condici√≥ externa</li>
      <li> Usa `IF` per bifurcar el comportament del codi</li>
      <li>‚ö†Ô∏è Evita bucles infinits, assegura sempre una condici√≥ de sortida</li>
    </ul>
  </section>
  

  <section id="proc-func">
    <h2>‚öôÔ∏è Procediments, Funcions i Triggers</h2>
  
    <h3> Definicions r√†pides</h3>
    <ul>
      <li><strong>Procediment:</strong> bloc PL/SQL que realitza una acci√≥, pot tenir par√†metres per√≤ no retorna valor directament.</li>
      <li><strong>Funci√≥:</strong> com un procediment, per√≤ <strong>retorna un valor</strong> mitjan√ßant <code>RETURN</code>.</li>
      <li><strong>Trigger:</strong> bloc de codi que s'executa autom√†ticament <strong>quan es produeix un esdeveniment</strong> sobre una taula (INSERT, UPDATE, DELETE).</li>
    </ul>
  
    <hr><h3>Permisos necessaris</h3>
    <p> ‚ùó Un usuari necessita tindre perm√≠s per executar rutines, o per crear-les i executar-es !!</p>
    <pre>GRANT CREATE PROCEDURE, CREATE TRIGGER TO &lt;usu>;
        -- (si t√© perm√≠s de crear, tamb√© pot executar)
GRANT EXECUTE ON &lt;esquema>.&lt;procedim> TO &lt;usu>/&lt;rol> [WITH GRANT OPTION];</pre>
    <p>El perm√≠s <strong>CREATE PROCEDURE</strong> val per procediments, I tamb√© per funcions</p>    
    <p>El perm√≠s <strong>CREATE TRIGGER</strong> val per disparadors</p>    

    <h3>Vista del DD</h3>
    <p>Per vore si un usuari t√© estos permisos</p>
    <pre>SELECT *
FROM DBA_SYS_PRIVS
WHERE privilege IN ('CREATE PROCEDURE', 'CREATE TRIGGER');
</pre>

    <hr><h3> PROCEDURE ‚Äì Procediment</h3>
    <p>Els procediments <strong>NO retornen valor</strong> i NO poden ser cridades dins SELECT o expressions. 
      Poden ser cridats des de dins d'un bloc an√≤nim, directament des de linea d'ordres sqlplus o SQL Developer, 
      , des de dins d'un altre procediment o funci√≥, o des del <strong>DBMS_SCHEDULER</strong> amb un <strong>job</strong></p>
      <h4>Exemples</h4>
      <pre>BEGIN
  DBMS_OUTPUT.PUT_LINE('Susp√®s')
  afegir_client('Maria', 'Gonzalez', '123456789');  
  actualitzar_sou(101, 3000); 
END; </pre>

    <hr>
      <h3> FUNCTION ‚Äì Funci√≥</h3>
      <h4> Difer√®ncia clau:</h4>
    <p>Les funcions <strong>retornen un valor</strong> i poden ser cridades des de dins de SELECT o expressions.</p>
    <h4>Exemples</h4>
    <pre>BEGIN
  data_actual := SYSDATE;
  valor_aleatori := DBMS_RANDOM.VALUE(1, 100);
  data_convertida := TO_DATE('2025-04-20', 'YYYY-MM-DD');

  SELECT upper(nom) , sysdate, sou FROM empleats;
  SELECT CONCAT(nom, ' ', cognom) FROM clients;
  SELECT sysdate FROM dual;
END;      </pre>

    <hr>
  
    <h3> TRIGGER ‚Äì Disparador</h3>
    <h4> Difer√®ncia clau:</h4>
    <p>Els trigger <strong>no retornen un valor, i no se'ls pot cridar</strong> Son blocs de codi amb nom que son cridats
       automaticament pel sistema quan passa algun esdeveniment.</p>
    <ul> Com..
      <li>Esdeveniment DML: INSERT, UPDATE, DELETE</li>
      <li>Esdeveniment DDL: CREATE, ALTER, DROP, ...</li>
      <li>Esdeveniments de base de dades: LOGON, LOGOFF, STARTUP, SHUTDOWN, etc.</li>
    </ul>

    <h4>Exemples</h4>
   <pre>-- Al Inserir un nou empleat es disparara el trigger associat 
-- al INSERT en la taula EMPLEATS
INSERT INTO empleats (id_empleat, nom, cognom, sou)   
VALUES (101, 'Joan', 'Garc√≠a', 2500);
-- En este moment, el sistema crida al trigger      </pre>
    
  </section>
    


<section id="procediments">
  <h2>‚öôÔ∏è Procediments en PL/SQL</h2>

  <h3> Qu√® √©s un procediment?</h3>
  <p>
    Un <strong>procediment</strong> √©s un bloc de codi PL/SQL <strong>emmagatzemat amb un nom</strong> que es pot cridar per executar una acci√≥. 
    Pot rebre par√†metres i fer servir sent√®ncies SQL, estructures de control, bucles, excepcions, etc.
  </p>

  <h3> Estructura b√†sica</h3>
  <pre>
CREATE [OR REPLACE] PROCEDURE nom_proc (
    param1 [IN | OUT | IN OUT] tipus,
    ...
) IS
BEGIN
   -- Codi del procediment
END nom_proc;
  </pre>

  <h4> Tipus de par√†metres:</h4>
  <ul>
    <li><code>IN</code>: entrada (per defecte)</li>
    <li><code>OUT</code>: sortida</li>
    <li><code>IN OUT</code>: entrada i sortida</li>
  </ul>
  <p>Sols vorem els IN, que a m√©s a m√©s, no cal posar la paraula IN perqu√® √©s el tipus per defecte</p>

  <h3> üß™ Exemple senzill</h3>
  <pre>
CREATE OR REPLACE PROCEDURE saluda (nom VARCHAR2) IS
BEGIN
   DBMS_OUTPUT.PUT_LINE('Hola, ' || nom || '!');
END;
  </pre>

  <p><strong>Execuci√≥:</strong></p>
  <pre>
BEGIN
   saluda('Joan');
END;
  </pre>
  <P>O tamb√© amb  <code>execute</code></P>
  <pre>execute mostrar_salutacio('Ada');</pre>

  <h3>üìò Consultar procediments</h3>
  <ul>
    <li> Llistar procediments de l‚Äôusuari:</li>
    <pre>
SELECT object_name FROM user_objects WHERE object_type = 'PROCEDURE';
    </pre>

    <li>üëÄ Consultar par√†metres d‚Äôun procediment:</li>
    <pre>
SELECT argument_name, in_out, data_type
FROM user_arguments
WHERE object_name = 'CALCULA_DOBLE';
    </pre>
  </ul>

  <h3> üßπ Esborrar un procediment</h3>
  <pre>
DROP PROCEDURE nom_proc;    </pre>  

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Dona noms clars i significatius</li>
    <li> Documenta el comportament i els par√†metres</li>
    <li> Gestiona excepcions amb <code>EXCEPTION</code> per capturar errors</li>
    <li>‚ö†Ô∏è Evita fer massa coses dins d‚Äôun sol procediment ‚Üí separa funcionalitats</li>
  </ul>

  <h3> Exemple complet amb control d‚Äôerrors</h3>
  <pre>
CREATE OR REPLACE PROCEDURE insereix_alumne (
   nom IN VARCHAR2,
   edat IN NUMBER
) IS
BEGIN
   INSERT INTO alumnes(nom, edat) VALUES (nom, edat);
   DBMS_OUTPUT.PUT_LINE('Alumne inserit correctament.');
EXCEPTION
   WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;    </pre>



  <h2> Formes de cridar / invocar un procediment</h2>
  <ul>
    <li>Notaci√≥ posicional</li>
    <li>Notaci√≥ nominal</li>
  </ul>
  <pre><code>afegir_client('Joan', 'Garc√≠a', '123456789');
afegir_client( p_nom => 'Joan', p_cognom => 'Garc√≠a', p_telefon => '123456789');
o
afegir_client(p_telefon => '123456789', p_nom => 'Joan', p_cognom => 'Garc√≠a');     </code>  </pre>
    <p>Totes s√≥n correctes</p>

</section>


<section id="funcions">
  <h2> Funcions en PL/SQL</h2>

  <h3>üìò Qu√® √©s una funci√≥?</h3>
  <p>
    Una <strong>funci√≥</strong> √©s un bloc de codi PL/SQL que <strong>rep zero o m√©s par√†metres</strong> i <strong>retorna un valor</strong>.
    A difer√®ncia dels procediments, les funcions es poden cridar dins sent√®ncies SQL i expressions.
  </p>
  <p>Al igual que en els procediments existeixen funcions predefinides que podem utilitzar en oracle</p>

  <table>
    <thead>
      <tr >
        <th>Tipus de Funcions</th>
        <th>Funcions</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Funcions Num√®riques</strong></td>
        <td>ROUND, TRUNC, MOD, SQRT, POWER, SIGN, ABS</td>
      </tr>
      <tr>
        <td><strong>Funcions de Cadenes (Strings)</strong></td>
        <td>LOWER, UPPER, TRIM, SUBSTR, LENGTH, REPLACE, INSTR, TRANSLATE, CHR, ASCII</td>
      </tr>
      <tr>
        <td><strong>Funcions per treballar amb NULL</strong></td>
        <td>NVL, NVL2, NULLIF, COALESCE</td>
      </tr>
      <tr>
        <td><strong>Funcions de Dates</strong></td>
        <td>SYSDATE, LAST_DAY, EXTRACT, ADD_MONTHS</td>
      </tr>
      <tr>
        <td><strong>Funcions de Conversi√≥</strong></td>
        <td>TO_NUMBER, TO_DATE, TO_CHAR</td>
      </tr>
    </tbody>
  </table>
  
  <p>I, al igual que en els procediments , podem definir noves funcions (funcions definides per l'usuari)</p>
  <p>Hem de tindre en compte, que una funci√≥ necessita <strong>saber</strong> quin tipus de dada va a retornar, i, 
    a m√©s a m√©s, en algun punt del cos de la funci√≥, ha de <strong>retornar</strong> una dada d'aquest tipus</p>

  <h3> Estructura b√†sica</h3>
  <pre>
CREATE [OR REPLACE] FUNCTION nom_func (  par√†metres  ) 
RETURN tipus 
IS
BEGIN
    -- codi
    RETURN valor;
END nom_func;
  </pre>

  <h3> Exemple simple</h3>
  <pre>
CREATE OR REPLACE FUNCTION suma ( a NUMBER, b  NUMBER ) 
RETURN NUMBER 
IS
BEGIN
   RETURN a + b;
END;
  </pre>

  <h4>Exemple Crida dins d‚Äôun bloc:</h4>
  <pre>
DECLARE
   resultat NUMBER;
BEGIN
   resultat := suma(4, 5);
   DBMS_OUTPUT.PUT_LINE('Resultat: ' || resultat);
END;
  </pre>

  <h4> Exemple Crida dins d'un SELECT</h4>
  <pre>
SELECT suma(10, 20) FROM dual;
  </pre>

  <h3> Exemple real: calcular salari amb plus</h3>
  <pre>
CREATE OR REPLACE FUNCTION salari_total ( base NUMBER, plus NUMBER DEFAULT 0 ) 
RETURN NUMBER 
IS
BEGIN
   RETURN base + plus;
END;
  </pre>

  <p>Crida:</p>
  <pre>
SELECT salari_total(1500, 200) FROM dual;
  </pre>

  <h3> Tipus de par√†metres</h3>
  <ul>
    <li><code>IN</code>: entrada (per defecte)</li>
    <li><code>OUT</code> i <code>IN OUT</code> no es poden fer servir a funcions que es cridin dins SQL</li>
  </ul>

  <h3>‚ö†Ô∏è Limitacions</h3>
  <ul>
    <li>Les funcions que es criden des de SQL <strong>no poden modificar dades</strong> (no poden fer INSERT, UPDATE o DELETE)</li>
    <li>Han de ser deterministes: el resultat ha de dependre nom√©s dels valors d‚Äôentrada</li>
  </ul>

  <h3>üì• Consulta de funcions</h3>
  <pre>
-- Funcions de l‚Äôusuari
SELECT object_name FROM user_objects WHERE object_type = 'FUNCTION';

-- Arguments d‚Äôuna funci√≥
SELECT argument_name, data_type, in_out
FROM user_arguments
WHERE object_name = 'SUMA';
  </pre>

  <h3>üß™ Exemple amb condici√≥</h3>
  <pre>
CREATE OR REPLACE FUNCTION es_parell (n IN NUMBER)
RETURN VARCHAR2 IS
BEGIN
   IF MOD(n, 2) = 0 THEN
      RETURN 'S√≠';
   ELSE
      RETURN 'No';
   END IF;
END;
  </pre>

  <p>Crida:</p>
  <pre>SELECT es_parell(8) FROM dual;</pre>

  <h3> Com cridar funcions:</h3>
  <ul>
    <li>‚úîÔ∏è Dins <code>SELECT</code>, <code>WHERE</code>, <code>ORDER BY</code></li>
    <li>‚úîÔ∏è Assignant a una variable dins un bloc</li>
    <li>‚ùå No es poden fer servir dins DML (si tenen codi que modifica dades)</li>
  </ul>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Utilitza noms clars i descriptius</li>
    <li> Fes servir <code>RETURN</code> nom√©s una vegada si √©s possible</li>
    <li> Documenta qu√® fa la funci√≥ i qu√® retorna</li>
    <li>‚ö†Ô∏è Evita fer INSERT/UPDATE dins funcions si s‚Äôhan de cridar des de SQL</li>
  </ul>

  <h3>üß™ Pr√†ctica combinada</h3>
  <p>Calcular l‚ÄôIRPF aplicat a un salari i retornar-lo:</p>
  <pre>
CREATE OR REPLACE FUNCTION calcula_irpf (
   salari IN NUMBER
) RETURN NUMBER IS
BEGIN
   RETURN salari * 0.15;
END;
  </pre>

  <p>
    Aquesta funci√≥ es pot cridar dins un SELECT per veure quants impostos es retenen:
  </p>
  <pre>
SELECT nom, calcula_irpf(salari) AS irpf
FROM empleats;
  </pre>

  <h3>üìò Consultes √∫tils al DD</h3>
  <pre>
-- Veure procediments i funcions de l'usuari
SELECT object_name, object_type
FROM user_objects
WHERE object_type IN ('PROCEDURE', 'FUNCTION');   </pre>  

<h3>üßπ Esborrar una funci√≥</h3>
<pre>DROP FUNCTION nom_de_la_funcio; </pre>
<p>‚ö†Ô∏è Consideracions:</p>
<ul>
  <li>Assegura‚Äôt que no hi ha cap procediment, vista o altre objecte que depenga d‚Äôeixa funci√≥ abans d‚Äôeliminar-la.</li>
  <li>Si la funci√≥ no existeix, Oracle donar√† un error</li>
</ul>

</section>




<section id="disparadors">
  <h2>üö® Disparadors (Triggers) en Oracle</h2>

  <h3>üìò Qu√® √©s un trigger?</h3>
  <p>
    Un <strong>trigger</strong> √©s un bloc de codi PL/SQL que s‚Äôexecuta autom√†ticament quan es produeix un <strong>esdeveniment</strong> 
    (com un INSERT, UPDATE o DELETE) sobre una taula o vista.
  </p>

  <h3> El bloc de codi del trigger s'executara:</h3>
  <ul>
    <li><strong>BEFORE</strong>: abans de l‚Äôesdeveniment</li>
    <li><strong>AFTER</strong>: despr√©s de l‚Äôesdeveniment</li>
    <li><strong>INSTEAD OF</strong>: per a vistes, substitueix l‚Äôacci√≥</li>
  </ul>
  <p>Segons el cas, es poden utilitzar valors d‚Äôuna fila abans de la operaci√≥ o despr√©s de l‚Äôoperaci√≥: Per fer aix√≤ s'usar√† <code><strong>:NEW  o  :OLD</strong></code></p>

  <h3> Nivells d‚Äôactuaci√≥</h3>
  <ul>
    <li> <strong>Fila a fila</strong> ‚Üí actua per cada fila afectada (s'indica posant FOR EACH ROW)</li>
    <li> <strong>Per esdeveniment</strong> ‚Üí actua una sola vegada per operaci√≥ (s'indica no posant res)</li>
  </ul>
  
  <h3> Sintaxi b√†sica (fila a fila)</h3>
  <pre>
CREATE OR REPLACE TRIGGER nom_trigger
BEFORE INSERT OR UPDATE OR DELETE
ON nom_taula
FOR EACH ROW
BEGIN
   -- accions amb :NEW i :OLD
END;
  </pre>

  <h3>üß™ Exemple: trigger de control INSERT</h3>
  <pre>
CREATE OR REPLACE TRIGGER log_insercio
AFTER INSERT ON alumnes
FOR EACH ROW
BEGIN
   DBMS_OUTPUT.PUT_LINE('Nou registre afegit: ' || :NEW.nom);
END;
  </pre>
  <p><code>:NEW</code> i <code>:OLD</code> representen els valors nous i antics respectivament per a cada fila.</p>

  <h3> Exemple: trigger per a impedir valors negatius</h3>
  <pre>
CREATE OR REPLACE TRIGGER evitar_negatius
BEFORE INSERT OR UPDATE ON productes
FOR EACH ROW
BEGIN
   IF :NEW.preu < 0 THEN
      RAISE_APPLICATION_ERROR(-20001, 'El preu no pot ser negatiu');
   END IF;
END;
  </pre>
  <ul>
    <li>
      <p>RAISE_APPLICATION_ERROR √©s una funci√≥ de PL/SQL que serveix per llan√ßar un error personalitzat dins d'una aplicaci√≥ o procediment.
        Quan es vol aturar l'execuci√≥ i mostrar un missatge d'error clar i espec√≠fic al teu codi, s'utilitzar√† <code><strong>RAISE_APPLICATION_ERROR</strong></code>.
        Aix√≤ √©s molt √∫til per validar dades o controlar condicions especials</p>
        <pre>RAISE_APPLICATION_ERROR(error_number, message[, {TRUE | FALSE}]); </pre>
        <ul>
          <li>error_number ‚Üí un n√∫mero d‚Äôerror entre -20000 i -20999 (Oracle reserva aquests codis per errors definits per l‚Äôusuari).</li>
          <li>message ‚Üí el missatge que vols mostrar quan succeeix l‚Äôerror.</li>
          <li>TRUE / FALSE ‚Üí opcional, indica si l‚Äôerror es registrar√† a l‚Äôalert log.</li>
        </ul>
    </li>
  </ul>
   <br>
  <h3> Exemple: trigger d‚Äôauditoria</h3>
  <p>Crear una taula d‚Äôauditoria:</p>
  <pre>
CREATE TABLE aud_alumnes (
   usuari   VARCHAR2(30),
   data_op  DATE,
   accio    VARCHAR2(10)
);
  </pre>

  <p>Trigger que afegeix registre:</p>
  <pre>
CREATE OR REPLACE TRIGGER audita_alumnes
AFTER INSERT OR DELETE ON alumnes
FOR EACH ROW
BEGIN
   INSERT INTO aud_alumnes VALUES (
      USER,
      SYSDATE,
      CASE
         WHEN INSERTING THEN 'INSERT'
         WHEN DELETING THEN 'DELETE'
      END
   );
END;
  </pre>
 
  <h3>üìò Consultes √∫tils al DD</h3>
  <pre>
-- Veure triggers de l‚Äôusuari actual
SELECT trigger_name, table_name, triggering_event, status
FROM user_triggers;

-- Consultar codi d'un trigger
SELECT trigger_body FROM user_triggers WHERE trigger_name = 'LOG_INSERCIO';
  </pre>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Usa noms clars i descripci√≥ funcional</li>
    <li> Documenta el comportament del trigger</li>
    <li> Evita codi complex o accions que modifiquin altres taules si no √©s necessari</li>
    <li> Controla el rendiment: massa triggers poden degradar l‚Äôefici√®ncia</li>
    <li> Si cal registrar accions, fes servir una taula d‚Äôauditoria</li>
  </ul>

  <h3>üõ†Ô∏è Activaci√≥ i desactivaci√≥ de triggers</h3>
  <pre>-- Desactivar
ALTER TRIGGER log_insercio DISABLE;

-- Activar
ALTER TRIGGER log_insercio ENABLE;    </pre>

  <h3>üóëÔ∏è Eliminar un trigger</h3>
  <pre>DROP TRIGGER log_insercio;</pre>
</section>




<section id="seq">
  <h2> Seq√º√®ncies en Oracle</h2>

  <h3>üìò Qu√® √©s una seq√º√®ncia?</h3>
  <p>
    Una <strong>seq√º√®ncia</strong> √©s un objecte de base de dades que genera una s√®rie de valors num√®rics consecutius, normalment 
    usats per a claus prim√†ries, codis √∫nics o control d‚Äôidentificadors.  
    √âs l‚Äôequivalent a un <em>autoincrement</em> en altres SGBD.
  </p>

  <h3> Crear una seq√º√®ncia</h3>
  <pre>-- Donar perm√≠s
GRANT CREATE SEQUENCE TO usuari;
-- Crear seq√º√®ncia 
CREATE SEQUENCE seq_alumnes START WITH 1 INCREMENT BY 1 
-- Esborrar seq√º√®ncia
DROP SEQUENCE seq_alumnes;  </pre>

  <h3> √ös de la seq√º√®ncia</h3>
  <p>Per obtenir el seg√ºent valor (es pot fer servir a INSERTs):</p>
  <pre>
seq_alumnes.NEXTVAL </pre>

  <p>Per consultar el valor actual (despr√©s d'haver fet NEXTVAL com a m√≠nim una vegada):</p>
  <pre>seq_alumnes.CURRVAL   </pre>

  <h4> Exemple d‚Äô√∫s en una inserci√≥</h4>
  <pre>INSERT INTO alumnes (id, nom, edat)  VALUES (seq_alumnes.NEXTVAL, 'Laia', 21);   </pre>

  <h3>üìò Consultar seq√º√®ncies existents</h3>
  <pre>-- Seq√º√®ncies de l‚Äôusuari
SELECT sequence_name, min_value, max_value, increment_by
FROM user_sequences;    </pre>

  <h3>‚öôÔ∏è Modificar una seq√º√®ncia</h3>
  <pre>
ALTER SEQUENCE seq_alumnes  INCREMENT BY 5 ;  </pre>

  <h3>üóëÔ∏è Eliminar una seq√º√®ncia</h3>
  <pre>
DROP SEQUENCE seq_alumnes;   </pre>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Usa <code>NOCYCLE</code> per evitar duplicats si no vols que torni a comen√ßar</li>
    <li> Usa <code>CACHE</code> per millor rendiment en entorns grans (ex: <code>CACHE 20</code>)</li>
    <li> No facis servir <code>CURRVAL</code> abans d‚Äôhaver cridat <code>NEXTVAL</code> en la sessi√≥</li>
    <li> Dona noms clars i relacionats amb la taula (ex: <code>SEQ_FACTURES</code>)</li>
  </ul>

  <h3> Exemple complet</h3>
  <pre>CREATE SEQUENCE seq_factura START WITH 1000 INCREMENT BY 10 ;
-- Inserci√≥ amb NEXTVAL
INSERT INTO factures (id, data_emissio) VALUES (seq_factura.NEXTVAL, SYSDATE);   </pre>

<h3>Identity Column</h3>
<p>Una <strong>identity column</strong>  √©s un altre mecanisme d‚Äôoracle per generar valors sencers seq√ºencials √∫nics i
   assignar-li'ls a camps num√®rics; s'utilitzen generalment per a les claus prim√†ries de les taules 
   garantint que els seus valors no es repetisquen.</p>
<pre>CREATE TABLE empleados (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY
  PRIMARY KEY,
  .......);</pre>

  <table>
    <thead style="background-color: #f2f2f2;">
      <tr>
        <th>Caracter√≠stica</th>
        <th>SEQUENCE</th>
        <th>IDENTITY Column</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Definici√≥</strong></td>
        <td>Objecte independent que genera valors num√®rics seq√ºencials.</td>
        <td>Columna d'una taula que genera autom√†ticament valors √∫nics.</td>
      </tr>
      <tr>
        <td><strong>√ös principal</strong></td>
        <td>Generar claus prim√†ries o valors seq√ºencials a voluntat.</td>
        <td>Generar autom√†ticament un valor √∫nic per fila nova.</td>
      </tr>
      <tr>
        <td><strong>Com s'utilitza</strong></td>
        <td>Cal cridar `nom_seq.NEXTVAL` expl√≠citament en la inserci√≥.</td>
        <td>Oracle gestiona el valor autom√†ticament (amb `GENERATED ALWAYS` o `BY DEFAULT`).</td>
      </tr>
      <tr>
        <td><strong>Control de valor</strong></td>
        <td>L'usuari decideix quan i com consumir el seg√ºent valor.</td>
        <td>El valor s'incrementa autom√†ticament amb cada inserci√≥ (segons la configuraci√≥).</td>
      </tr>
      <tr>
        <td><strong>Flexibilitat</strong></td>
        <td>Molt flexible: pot ser utilitzada per diferents taules o processos.</td>
        <td>Est√† lligada a una sola taula i columna.</td>
      </tr>
      <tr>
        <td><strong>Exemple de creaci√≥</strong></td>
        <td><code>CREATE SEQUENCE seq_client_id START WITH 1 INCREMENT BY 1;</code></td>
        <td><code>id NUMBER GENERATED BY DEFAULT AS IDENTITY</code></td>
      </tr>
      <tr>
        <td><strong>Compartici√≥ entre taules</strong></td>
        <td>Es pot usar en m√∫ltiples taules.</td>
        <td>Nom√©s es pot usar en una taula espec√≠fica.</td>
      </tr>
    </tbody>
  </table>
    

</section>




<section id="cursors">
  <h2> Cursors en PL/SQL</h2>

  <h3>üìò Qu√® √©s un cursor?</h3>
  <img src="imgs/cursor-gen.png" alt="cursor" width="30%" class="imatge-dreta">
  <p>
    Un <strong>cursor</strong> √©s un mecanisme de PL/SQL que permet <strong>rec√≥rrer m√∫ltiples files</strong>
     retornades per una consulta <code>SELECT</code>. Un cursor √©s com un punter que apunta a un conjunt de resultats d'una SQL i 
     deixa llegir-los u a u. 
  </p>
  <p>Serveix per treballar fila a fila amb el conjunt de resultats, com un bucle sobre una taula.</p>

  <h3> Tipus de cursors</h3>
  <ul>
    <li><strong>Impl√≠cits:</strong> creats autom√†ticament per Oracle per a sent√®ncies DML (SELECT .. INTO, INSERT, UPDATE...) )</li>
    <li><strong>Expl√≠cits:</strong> definits manualment per l‚Äôusuari per tractar SELECTs que tornen m√∫ltiples files</li>
    <li><strong>FOR cursors:</strong> simplificaci√≥ de l‚Äô√∫s expl√≠cit</li>
  </ul>

  <hr>
  <h3> Cursors impl√≠cits</h3>
  <p>No es declaren, sols tornen un resultat o fila:</p>
  <pre>SELECT DESCRIPCION INTO vdescripcion from PAISES WHERE CO_PAIS = 'ESP';   </pre>

<p>Els cursors impl√≠cits nom√©s poden retornar una √∫nica fila. En cas que es retorne m√©s d'una fila 
  (o cap fila) es produir√† una <strong>excepci√≥</strong>: NO_DATA_FOUND o TOO_MANY_ROWS.  Esta <strong>EXCEPCI√ì</strong> podr√† ser capturada i tractada</p>

  <p>Si no sabem si va a tornar cap fila o m√©s d'una, es pot comprobar abans amb</p>
  <pre>SELECT count(*) INTO vcant from factura WHERE idcli = 'V00923';</pre>
  <p>O utilitzar una EXCEPTION i preguntar per %FOUND</p>

  
  <h3> Atributs √∫tils</h3>
  <ul> Quan Oracle crea un cursor impl√≠cit, el seu nom l√≤gic √©s SQL, i es pot consultar l‚Äôestat amb atributs:
    <li><code>sql%FOUND</code> ‚Üí si s‚Äôha trobat almenys una fila</li>
    <li><code>sql%NOTFOUND</code> ‚Üí si no s‚Äôha trobat cap fila</li>
    <li><code>sql%ROWCOUNT</code> ‚Üí nombre de files tractades</li>
    <li><code>sql%ISOPEN</code> ‚Üí indica si el cursor est√† obert</li>
  </ul>

  <hr>
  <h3> √ös d‚Äôun cursor expl√≠cit</h3>
  <p><strong>Passos:</strong></p>
  <ol>
    <li>Declarar el cursor</li>
    <li>Obrir-lo</li>
    <li>Llegir fila a fila</li>
    <li>Tancar-lo</li>
  </ol>

  <h4> Exemple complet</h4>
  <pre>DECLARE
   CURSOR c_alumnes IS
     SELECT nom, edat FROM alumnes;
   
   v_nom alumnes.nom%TYPE;
   v_edat alumnes.edat%TYPE;
BEGIN
   OPEN c_alumnes;
   LOOP
      FETCH c_alumnes INTO v_nom, v_edat;
      EXIT WHEN c_alumnes%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('Nom: ' || v_nom || ' - Edat: ' || v_edat);
   END LOOP;
   CLOSE c_alumnes;
END;   </pre>

  <hr>

  <h3> Cursor FOR ‚Äì simplificat</h3>
  <p>Oracle gestiona autom√†ticament l‚Äôobertura, lectura i tancament.</p>
  <pre>BEGIN
   FOR reg IN (SELECT nom, edat FROM alumnes) LOOP
      DBMS_OUTPUT.PUT_LINE('Nom: ' || reg.nom || ', Edat: ' || reg.edat);
   END LOOP;
END;   </pre>

  <h3> Cursors amb par√†metres</h3>
  <pre>DECLARE
   CURSOR c_per_edat(min_edat NUMBER) IS
     SELECT nom FROM alumnes WHERE edat > min_edat;

   v_nom alumnes.nom%TYPE;
BEGIN
   OPEN c_per_edat(18);
   LOOP
      FETCH c_per_edat INTO v_nom;
      EXIT WHEN c_per_edat%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('Major de 18: ' || v_nom);
   END LOOP;
   CLOSE c_per_edat;
END;    </pre>

  <hr>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Sempre tanca els cursors despr√©s d‚Äôusar-los</li>
    <li> Utilitza <strong>FOR cursors</strong> si nom√©s necessites llegir</li>
    <li> Evita FETCHs sense <code>EXIT WHEN %NOTFOUND</code></li>
    <li> Reutilitza variables amb tipus %TYPE o %ROWTYPE</li>
  </ul>

  <h3>üìò Consulta de cursors actius</h3>
  <p>(per sessions de treball, administradors)</p>
  <pre>
SELECT * FROM v$open_cursor
WHERE user_name = 'NOM_USUARI';
  </pre>
</section>



<section id="excepcions">
  <h2>Gesti√≥ d‚ÄôExcepcions en PL/SQL</h2>

  <h3>üìò Qu√® √©s una excepci√≥?</h3>
  <p>
    Una <strong>excepci√≥</strong> √©s una situaci√≥ d‚Äôerror que es produeix durant l‚Äôexecuci√≥ d‚Äôun bloc PL/SQL.
    Oracle permet capturar aquestes situacions per gestionar-les de manera controlada i evitar que el bloc falli de manera abrupta.
  </p>

  <h3> Estructura general amb excepcions</h3>
  <pre>BEGIN
   -- codi normal
EXCEPTION
   WHEN tipus_excepcio THEN
      -- codi d'error
END;   </pre>

  <h3> Tipus d‚Äôexcepcions</h3>

  <h4> Excepcions predefinides</h4>
  <p>Oracle les reconeix autom√†ticament. Exemple:</p>
  <ul>
    <li><code>NO_DATA_FOUND</code> ‚Üí no hi ha resultats</li>
    <li><code>TOO_MANY_ROWS</code> ‚Üí SELECT retorna m√©s d‚Äôuna fila</li>
    <li><code>ZERO_DIVIDE</code> ‚Üí divisi√≥ per zero</li>
    <li>....</li>
  </ul>
  <a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-error-handling.html#GUID-8C327B4A-71FA-4CFB-8BC9-4550A23734D6">
    Es pot consultar la llista sencera en la documentaci√≥ oficial d'oracle ac√≠    </a> . I de la pr√≤xima versi√≥ 26
     <a href="https://docs.oracle.com/en/database/oracle/oracle-database/26/lnpls/predefined-exceptions.html">_ac√≠_</a>

  <h4> Exemple</h4>
  <pre>DECLARE
   v_nom alumnes.nom%TYPE;
BEGIN
   SELECT nom INTO v_nom FROM alumnes WHERE id = 999;
   DBMS_OUTPUT.PUT_LINE(v_nom);
EXCEPTION
   WHEN NO_DATA_FOUND THEN
      DBMS_OUTPUT.PUT_LINE('Cap alumne amb aquest ID');
END;   </pre>

  <h4> Excepcions no predefinides</h4>
  <p>Oracle les pot capturar amb <code>SQLCODE</code> i <code>SQLERRM</code>:</p>
  <pre>BEGIN
   -- operaci√≥ que pot fallar
EXCEPTION
   WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error ' || SQLCODE || ': ' || SQLERRM);
END;    </pre>

  <h4>üîß Excepcions personalitzades</h4>
  <p>Es poden declarar amb <code>EXCEPTION</code> i cridar amb <code>RAISE</code>:</p>
  <pre>DECLARE
   ex_preu_invalid EXCEPTION;
   v_preu NUMBER := -5;
BEGIN
   IF v_preu &lt; 0 THEN
      RAISE ex_preu_invalid;
   END IF;
EXCEPTION
   WHEN ex_preu_invalid THEN
      DBMS_OUTPUT.PUT_LINE('Error: preu negatiu no v√†lid');
END;  </pre>

  <h3> Claus d‚Äô√∫s</h3>
  <ul>
    <li><code>RAISE</code> ‚Üí provoca una excepci√≥</li>
    <li><code>WHEN ... THEN</code> ‚Üí captura una excepci√≥</li>
    <li><code>WHEN OTHERS THEN</code> ‚Üí captura qualsevol error no gestionat abans</li>
    <li><code>SQLERRM</code> ‚Üí mostra el missatge d‚Äôerror</li>
    <li><code>SQLCODE</code> ‚Üí mostra el codi num√®ric de l‚Äôerror</li>
  </ul>

  <h3>üß† Exemple final combinat</h3>
  <pre>DECLARE
   v_total NUMBER := 0;
BEGIN
   v_total := 100 / 0;
EXCEPTION
   WHEN ZERO_DIVIDE THEN
      DBMS_OUTPUT.PUT_LINE('No es pot dividir per zero!');
   WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error inesperat: ' || SQLERRM);
END;   </pre>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Captura errors espec√≠fics abans de fer servir <code>OTHERS</code></li>
    <li> Informa l‚Äôusuari o registra l‚Äôerror</li>
    <li> No capturis <code>OTHERS</code> sense mostrar cap missatge (silenciar errors √©s perill√≥s)</li>
    <li> Fes servir excepcions personalitzades quan tinguis validacions pr√≤pies</li>
  </ul>
</section>



<section id="tasques">
  <h2> üìÖ Tasques automatitzables en Oracle</h2>

  <h3> Qu√® podem automatitzar?</h3>
  <p>En un entorn Oracle, √©s habitual automatitzar tasques per millorar la gesti√≥ i el rendiment del sistema. Algunes de les tasques m√©s comunes s√≥n:</p>
  <ul>
    <li> Exportacions i c√≤pies de seguretat</li>
    <li> Importacions de dades</li>
    <li> Execuci√≥ d'informes</li>
    <li> Neteja de logs i arxius antics</li>
    <li> Tasques de manteniment peri√≤dic</li>
  </ul>

  <h3>üìÑ Scripts SQL i .bat</h3>
  <p>Pots crear scripts `.sql` amb comandes Oracle i executar-los des de scripts `.bat` o `.sh` mitjan√ßant <code>sqlplus</code>.</p>

  <h4> Exemple: script SQL</h4>
  <pre>-- arxiu: informe.sql
SET ECHO OFF
SET FEEDBACK OFF
SPOOL informe_resultats.txt

SELECT * FROM alumnes;

SPOOL OFF
EXIT;  </pre>

  <h4> üñ•Ô∏è Script .bat (Windows)</h4>
  <pre>-- arxiu: llan√ßa_informe.bat
sqlplus usuari/contrasenya@XE @informe.sql
pause    </pre>
<p>Una vegada creat el fitxer .bat, s'ha de crear una tasca programada. Panel de control ‚Üí Tareas programadas ‚Üí Agregar Tarea ‚Üí ...   </p>
<p>Consulta alguna guia de com usar el programador de tasques de Windows. <a href="https://www.adslzone.net/esenciales/windows-10/programar-tareas/"> guia1 </a>, 
<a href="https://openwebinars.net/blog/programacion-de-tareas-desde-la-terminal-de-windows/">guia2</a></p>

  <h4>üêß Script .sh (Linux)</h4>
  <pre>#!/bin/bash
sqlplus usuari/contrasenya@XE @informe.sql    </pre>
<p>En Linux, s'utilitza el CRON / CRONTAB per afegir tasques que s'executaran a determinades hores / dies () .  
Consulta alguna guia de com usar CRON <a href="https://www.redeszone.net/tutoriales/servidores/cron-crontab-linux-programar-tareas/">guia1</a>, 
<a href="https://www.arsys.es/blog/cron-jobs-una-guia-completa">guia2</a>, o <a href="https://www.hostinger.com/mx/tutoriales/sintaxis-crontab">guia3</a>, per a entendre les diferents opcions de programaci√≥ hor√†ria.  </p>
  <hr><h3>üìÜ Oracle SCHEDULER  -  JOBS </h3>
  <p>
    Oracle incorpora un sistema per programar tasques directament des de la base de dades: <strong>DBMS_SCHEDULER</strong>.
  </p>
  <h4> Donar perm√≠s</h4>
  <pre>--  Un usuari necessita tindre perm√≠s per crear jobs (treballs) i executar-los !!
GRANT CREATE JOB TO usuari;     -- crear i administrar els jobs seus
GRANT EXECUTE ON dbms_scheduler TO usuari;   -- sols administrar els seus jobs
 </pre>
 <pre>GRANT CREATE ANY JOB TO usuari;    crear jobs d'altres, i administrar-los</pre>


<!--  GRANT EXECUTE ON dbms_scheduler TO usuario;  -- ho pot fer SYSTEM
GRANT CREATE ANY JOB TO usuario    crear jobs d'altres, i administrar-los (ho pot fer system)
GRANT MANAGE SCHEDULER TO usuario;  -- admin jobs d'altres -- No ho pot fer SYSTEM !!, si ho pot fer SYS   
-- Dar permiso a otro usuario para ejecutar un job de tu esquema 
BEGIN
  DBMS_SCHEDULER.GRANT_PRIVILEGE(
    privilege   => 'EXECUTE',
    object_name => 'MI_JOB',
    grantee     => 'OTRO_USUARIO'
  );
END;     altres permisos ALTER, DROP, MANAGE

Altra forma :  DBMS_SCHEDULER.GRANT_PRIVILEGE('EXECUTE', 'MI_JOB', 'OTRO_USUARIO');   -->

  <h4> Crear una tasca programada</h4>
  <pre>BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
    job_name        => 'JOB_INFORME',
    job_type        => 'PLSQL_BLOCK',
    job_action      => 'BEGIN informe_alumnes(); END;',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY; BYHOUR=8',
    enabled         => TRUE
  );
END;    </pre>

    <h4>Executar sense esperar al moment programat</h4>
    <pre>BEGIN
    DBMS_SCHEDULER.RUN_JOB('JOB_INFORME');
END;</pre>

   <h4>Habilitar o deshabilitar la programaci√≥</h4>
   <pre>BEGIN
  DBMS_SCHEDULER.DISABLE('JOB_INFORME');
  DBMS_SCHEDULER.ENABLE('JOB_INFORME');
END; </pre>
  <h4> Modificar una tasca programada</h4>
  <pre>BEGIN
  dbms_scheduler.set_attribute_null( name=>'nom', attribute=>'a');
  dbms_scheduler.set_attribute(name=>'nom',attribute=>'a',value=>'v');
  -- ES POT CANVIAR : job_action , repeat_interval , comments, job_type (PLSQL_BLOCK' 'STORED_PROCEDURE' 'EXECUTABLE')
END;   </pre>  

<h4> Par√†metre  <code>repeat_interval</code> </h4>
<pre>FREQ=MONTHLY ‚Üí S'executa un cop al mes. (Defineix la repetici√≥ mensual)
BYMONTHDAY=1 El dia 1 de cada mes
BYDAY=TU ‚Üí Els dimarts.  ( abreviatures MO, TU, WE, TH, FR, SA i SU ).
BYSETPOS=1 ‚Üí Nom√©s el primer dimarts del mes.
BYHOUR=1; BYMINUTE=5 ‚Üí A la 01:05 AM.    </pre>
<p>FREQ={ DAILY | HOURLY | MINUTELY | WEEKLY | MONTHLY | YEARLY};
  A partir d‚Äôaqu√≠, pots afegir modificadors com BYSECOND, BYMINUTE, BYHOUR, BYDAY, BYMONTH, etc</p>
  <p>FREQ √©s el par√†metre que indica la freq√º√®ncia de repetici√≥ de la planificaci√≥</p>


<h4>Exemples d'√∫s del par√†metre</h4>
<pre>Cada dia a les 8:30 AM
REPEAT_INTERVAL => 'FREQ=DAILY; BYHOUR=8; BYMINUTE=30;'
Cada dilluns i dimecres a les 10:00 AM i 4:00 PM
REPEAT_INTERVAL => 'FREQ=WEEKLY; BYDAY=MON,WED; BYHOUR=10,16; BYMINUTE=0;'
El primer dimarts de cada mes a les 09:00 AM
REPEAT_INTERVAL => 'FREQ=MONTHLY; BYDAY=TU; BYSETPOS=1; BYHOUR=9; BYMINUTE=0;'
L'√∫ltim divendres de cada mes a les 18:00
REPEAT_INTERVAL => 'FREQ=MONTHLY; BYDAY=FR; BYSETPOS=-1; BYHOUR=18; BYMINUTE=0;'
Cada 6 hores
REPEAT_INTERVAL => 'FREQ=HOURLY; INTERVAL=6;'
Cada tres mesos
REPEAT_INTERVAL => 'FREQ=YEARLY; BYMONTH=JA,AP,JL,OC'  
     (abreviatures dels mesos: JA, FE, MR, AP, MA, JU, JL, AU, SE, OC, NO , DE)   </pre>

  <p class="alert">En Oracle DBMS_SCHEDULER, si no s‚Äôindica l‚Äôhora (BYHOUR, BYMINUTE, BYSECOND) en el REPEAT_INTERVAL, s‚Äôutilitza l‚Äôhora del START_DATE del job.</p>


  <h4>üìò Consultar jobs en el DD</h4>
  <pre>SELECT job_name, state FROM user_scheduler_jobs;  
SELECT * FROM user_scheduler_jobs;         </pre>

  <h4> Aturar o Eliminar un job</h4>
  <pre>BEGIN
  DBMS_SCHEDULER.STOP_JOB('JOB_INFORME');  
  DBMS_SCHEDULER.DROP_JOB('JOB_INFORME');
END;   </pre>

  <hr><h3> ‚è∞ Triggers de sistema (a nivell de sessi√≥)</h3>
  <p>Tamb√© pots utilitzar <strong>triggers de sistema</strong> per executar codi quan es produeixen accions espec√≠fiques:</p>
  <pre>CREATE OR REPLACE TRIGGER t_inici_sessio
AFTER LOGON ON DATABASE
BEGIN
  INSERT INTO log_sessio(usuario, data)   
  VALUES (USER, SYSDATE); 
END;   </pre>
<pre>Altres accions que es poden emprar:
     LOGON, LOGOFF, STARTUP, SHUTDOWN, ERRORLOGON</pre>

  <h3> Exemple complet d‚Äôautomatitzaci√≥</h3>
  <ul>
    <li> <code>informe.sql</code>: genera un informe amb SELECTs</li>
    <li> <code>informe.bat</code>: l‚Äôexecuta des del sistema</li>
    <li> <strong>DBMS_SCHEDULER</strong>: programa la seva execuci√≥ cada dia a les 8h</li>
  </ul>

  <h3> Bones pr√†ctiques</h3>
  <ul>
    <li> Guarda scripts en carpetes versionades (ex: GIT)</li>
    <li> Documenta les tasques automatitzades</li>
    <li> Revisa els permisos dels usuaris que executen les tasques</li>
    <li>‚ö†Ô∏è Evita duplicar jobs o crear-ne de recurrents sense control</li>
  </ul>

  <h3> SQL din√†mic</h3>
  <p>En algunes tasques de manteniment, s‚Äôutilitzar√† el diccionari de dades 
    (amb un cursor)- i per a cada objecte de DD s‚Äôaplicar√† una sent√®ncia DDL</p>
    <p class="alert">Si esta sent√®ncia correspon al DDL, no es pot executar directament dins d'un bloc de codi</p>
    <p>En este cas, es far√† √∫s de la sent√®ncia <code>execute immediate</code></p>
    <p><code>execute immediate</code> √©s una instrucci√≥ de PL/SQL que permet executar sent√®ncies SQL din√†miques
       √©s a dir, sent√®ncies constru√Ødes en temps d'execuci√≥ com cadenes de text.</p>
    <p>Exemple</p>
<pre>create procedure defrag_taules (vuser varchar2(20))
-- Este proc desfragmenta totes les taules d‚Äôun usuari/schema
as
cursor c is select table_name,tablespace_name
from dba_tables where user=vuser ;
begin
for x in c loop
  execute immediate ('alter table ' || x.table_name || ' move');
  dbms_output.put_line('Taula desfragmentada:' || x.table_name);
  end loop;
end;   </pre>


</section>


<section id="altres-recursos">
  <h2>Altres recursos</h2>
    <h3>√ös de Dates en Oracle</h3>
    <h2> <a href="dates-en-oracle.html">Dates en ORACLE</a></h2>
  
   <!--    <a href="">link</a> 
    <h3>AuithID en procedure</h3>

    <h3>FOR en procedure</h3>
    <h3> doble & en variable de substituci√≥  - &&dismeCodi</h3>
    -->

</section>


</main>

<script>

  // Per poder copiar codi en el porta-retalls. S'ha de posar un bot√≥ en cada <pre>
      //  <div class="pre-container">
      //    <button class="copy-button">Copia Codi !</button>
  document.addEventListener('DOMContentLoaded', function () {
    const buttons = document.querySelectorAll('.copy-button');

    buttons.forEach(button => {
      button.addEventListener('click', function () {
        const code = this.nextElementSibling.innerText;
        navigator.clipboard.writeText(code).then(() => {
          this.innerText = ' ‚úî Copiat!';
          setTimeout(() => this.innerText = 'Copia Codi !', 3000);
        });
      });
    });
  });

</script>

</body>
</html>
