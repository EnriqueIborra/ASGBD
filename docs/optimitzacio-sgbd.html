<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>üìà Monitoritzar Oracle</title>
  <link rel="stylesheet" href="estilsunitats.css">
  <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css" />
</head>
<body>

<header>
  <a href="./">
      <!--<img src="https://upload.wikimedia.org/wikipedia/commons/5/50/Oracle_logo.svg" alt="Oracle Logo"> -->
      <img src="imgs/ASGBD.png" alt="M√≤dul ASGBD">
  </a>
  <h1>ASGBD   -    Monitoritzaci√≥ i Optimitzaci√≥</h1>
</header>

<nav>
  <h3>√çndex</h3>
  <a href="#monitoratge">Monitoratge</a>
  <a href="#optimitzacio">Optimitzaci√≥</a>
  <a href="#optimitzacio-oracle">Optimitzaci√≥ en ORACLE</a>
  <a href="#eines-optimitzacio">Eines d'optimitzaci√≥</a>  
  <a href="#optimitzacio-objectes">Optimitzaci√≥ en objectes</a>  
  <a href="#altres-recursos">Altres Recursos</a> 
</nav>

<main>

  <section id="monitoratge">
    <h2> Monitoratge del Sistema Gestor de Bases de Dades (SGBD)</h2>
  
    <h3> Qu√® √©s el monitoratge?</h3>
    <p>El <strong>monitoratge</strong> √©s el proc√©s de controlar el funcionament del sistema gestor, detectant 
      possibles errors o situacions que puguin afectar el rendiment. 
      Ha de ser <strong>poc intrusiu</strong>, per tal de no interferir en el funcionament normal del sistema.
    </p>
    <p>S'ha de tractar que les tasques de monitoratge i diagn√≤stic del sistema siguen el menys intrusives possible 
      perqu√® no penalitzen el rendiment del sistema gestor, i relegar les tasques que requerisquen un consum de 
      recursos mitj√† o elevat per a realitzar-les en moments de baixa c√†rrega</p>
  
    <h3>üß∞ Eines principals de monitoratge</h3>
    <ul>
      <li> <strong>Monitor de rendiment</strong>: analitza c√†rrega, processos i consum de recursos.</li>
      <li> <strong>Log d‚Äôexecuci√≥</strong>: recull errors, avisos i operacions importants.</li>
      <li> <strong>Diccionari de dades (DD)</strong>: permet fer consultes per monitorar sessions, bloquejos, consultes actives, etc.</li>
    </ul>
  
    <h3> Monitor de rendiment</h3>
    <ul>
      <li>Seguiment de m√®triques de temps de resposta, concurr√®ncia i escalabilitat.</li>
      <li>Detecci√≥ de bloquejos i processos acaparadors.</li>
      <li>Consum de recursos.</li>
      <li>Configuraci√≥ d‚Äôalertes i llindars.</li>
    </ul>
  
    <h4> Dades rellevants</h4>
    <ul>
      <li>Temps de resposta i transaccions per usuari</li>
      <li>Escalabilitat i concurr√®ncia</li>
      <li>√ös de CPU, mem√≤ria i IO</li>
    </ul>
  
    <h3>üìù Registre d‚Äôerrors (fitxers de logs)</h3>
    <p>  Registra activitats com arrencades, aturades, errors, consultes lentes, etc.
    </p>
    <ul>
      <li> <strong>Error</strong>: problemes greus</li>
      <li> <strong>Warning</strong>: advert√®ncies</li>
      <li> <strong>Debug</strong>: informaci√≥ detallada (en desenvolupament)</li>
    </ul>
  
    <h4>üìÅ Exemples de fitxers de registre</h4>
    <ul>
      <li><code>alert.log</code></li>
      <li><code>trace</code></li>
      <li><code>incident</code></li>
      <li>Ubicaci√≥: <code>ORACLE_BASE/diag</code> (ADR - Automatic Diagnostic Repository)</li>
    </ul>
  
    <h3>üìö Diccionari de Dades (DD)</h3>
    <p> Conjunt de vistes com <code>v$session</code>, <code>v$sqlarea</code>, <code>v$diag_info</code>, etc. que permeten:
    </p>
    <ul>
      <li>Consultar qui est√† connectat i qu√® executa</li>
      <li>Detectar consultes pesades o bloquejos</li>
      <li>Visualitzar informaci√≥ de rendiment</li>
    </ul>
  
    <p> Exemple:</p>
    <pre>SELECT * FROM v$session;
SELECT * FROM v$sqlarea;
SELECT * FROM v$diag_info;  -- Registre d'errors      </pre>
  
    <h3>üñ•Ô∏è Monitoratge gr√†fic (SQL Developer, TOAD...)</h3>
    <p>‚ö†Ô∏è Les ferramentes gr√†fiques consumeixen m√©s recursos que les consultes al DD<br>
      ‚ö†Ô∏è Les ferramentes gr√†fiques requereixen m√©s permisos que les consultes al DD</p>
    <ul>
      <li>Historial de consultes (Ver ‚Üí DBA)</li>
      <li>ASH (Active Session History)</li>
      <li>AWR (Automatic Workload Repository)</li>
      <li>Top SQL, Sessions, Tasques de llarga durada</li>
    </ul>
  
    <p> Tamb√© es pot fer des de <code>Herramientas ‚Üí Controlar sesiones</code> en SQL Developer.</p>
  
    <h3> Pr√†ctica recomanada</h3>
    <ul>
      <li>Prioritzar consultes al Diccionari de Dades abans que eines gr√†fiques (consumeixen menys recursos)</li>
      <li>Fer monitoratge profund en hores de baixa c√†rrega</li>
      <li>Configurar alertes amb SCHEDULER o sistemes externs</li>
    </ul>
  
    <h3> Resum de bones pr√†ctiques</h3>
    <ul>
      <li> Supervisar l‚Äôactivitat del sistema peri√≤dicament</li>
      <li> Detectar i gestionar sessions bloquejades</li>
      <li> Reaccionar a errors recurrents als logs</li>
      <li> Fer √∫s de vistes com <code>v$session</code>, <code>v$active_session_history</code>, etc.</li>
    </ul>
  </section>
    



  <section id="optimitzacio">
    <h2> Optimitzaci√≥</h2>
  
    <h3>üéØ Objectiu</h3>
    <p>
      L‚Äôobjectiu de l‚Äôoptimitzaci√≥ √©s <strong>millorar el rendiment</strong> del sistema, tot reduint els temps de resposta, 
      l‚Äô√∫s de recursos i l‚Äôimpacte en l‚Äôusuari final. 
      No es tracta nom√©s de fer que les consultes funcionen, sin√≥ que siguen <strong>r√†pides i eficients</strong>.
    </p>
  <h3>Nivells on optimitzar</h3>
  <ul>
    Entorn
    <ul>  <li>a nivell de Sistema Operatiu</li>
    <li>a nivell de Xarxa</li>
    </ul>
    Sistema Gestor
    <ul>
      <li>Grand√†ria de blocs</li>
      <li>Grand√†ria i ubicaci√≥ de fitxers de dades</li>
      <li>Deshabilitar processos ocults</li>
      <li>Grand√†ria de l'emmagatzemament temporal</li>

    </ul>
    Base de Dades
    <ul>
      <li>Disseny de taules i tipus de dades (Ajustar al necessari)</li>
      <li>Camps calculats (intentar mantindre els menys possibles)</li>
      <li>Desnormalitzaci√≥ (reduir JOIN a costa de augmentar redund√†ncia)</li>
      <li>Desfragmentaci√≥</li>
      <li>Particionament </li>
      <li>Crear, modificar o eliminar √≠ndex</li>
      <li>Balanceig d‚Äô√≠ndex</li>
      <li>Optimitzaci√≥ de consultes </li>
    </ul>
  </ul>

  <h3>Particionament</h3>
  <li>S‚Äôevita processar tota una taula (sols es processa la partici√≥)</li>
  <li>Permet guardar en una sola taula m√©s dades que en un disc</li>
  <li>Les dades poden ser accedides en paral¬∑lel</li>
  <li>Facilita operacions com p.e. el purgat de dades</li>

  <h3>Creaci√≥ d'√≠ndex</h3>
  <ul>
  <li>Sobre que columnes crear
    <ul>
      <li>Claus primaries i alienes ( normalment ja ho fa el SGBD)</li>
      <li> Columnes que habitualment apareixen en SELECT i en WHERE</li> 
      <li> Columnes amb bona selectivitat ( si poques files tenen el mateix valor)</li> </ul> 
  </li>
  <li>Sobre que columnes NO crear 
    <ul>
      <li>Taules amb poques dades</li>
      <li>Columnes amb molts valors NULL</li> 
      <li>Columnes amb valors que es modifiquen molt sovint </li> 
      <li>√çndex sobre moltes columnes</li>
      <li>Molts √≠ndex per taula</li>
    </ul> 
  </li>

  <li>Que tipus d‚Äô√≠ndex crear
<ul><ul>Per organitzacio
    <li>Agrupats</li>
    <li>No agrupats</li>  </ul> </ul>
<ul><ul>Per estructura
      <li>√çndex B-tree</li>
      <li>√çndex bitmap</li>
      <li>√çndex hash</li>  </ul> </ul>
  </li>
</ul>

<h3> Optimitzaci√≥ de consultes</h3>
    <ul>
      <li>Substituir els OR per UNION </li>
      <li> IN vs EXISTS </li>
      <li>  IN vs BETWEEN</li>
      <li> Comparacions. Evitar IS NULL, i &lt;&gt; </li>
      <li>Usar taules derivades, subconsultes i joins </li>
      <li> Evitar el GROUP BY</li>
      <li>Cursors i funcions  </li>
      
    </ul>   
    <hr><hr>
       
    <h3> Pr√†ctiques recomanades per a √≠ndex</h3>
    <ul>
      <li> Columna freq√ºentment filtrada (WHERE)</li>
      <li> Columnes utilitzades en JOINs</li>
      <li>‚ö†Ô∏è No crear √≠ndexs per defecte a totes les columnes (consumeixen espai i poden alentir INSERT/UPDATE)</li>
    </ul>

    <h3> Pr√†ctiques recomanades per a consultes</h3>
    <ul>
      <li> Utilitza <code>EXPLAIN PLAN</code> per analitzar l'estrat√®gia de consulta (s'explica en el seg√ºent punt)</li>
      <li> Evita <code><strong>SELECT *</strong> </code>: nom√©s demana les columnes necess√†ries</li>
      <li> Evita subconsultes correlacionades no indexades</li>
      <li> Fes √∫s de joins eficients (preferentment expl√≠cits)</li>
      <li> Controla l‚Äô√∫s de funcions sobre columnes indexades</li>
    </ul>



    <h3>üõë Consultes ineficients</h3>
    <p>Exemples a evitar:</p>
    <ul>
      <li><code>SELECT * FROM taula;</code> ‚Üí molt cost√≥s si t√© moltes columnes</li>
      <li><code>WHERE TO_CHAR(data, 'YYYY') = '2023'</code> ‚Üí trenca √≠ndexs</li>
      <li><code>WHERE UPPER(nom) = 'JOAN'</code> ‚Üí si no hi ha √≠ndex amb UPPER</li>
    </ul>
  
    <h3> Versions millorades</h3>
    <pre>-- Evitar funcions sobre columnes
WHERE data >= TO_DATE('01/01/2023', 'DD/MM/YYYY')

-- Substituir subconsulta per JOIN
SELECT a.nom, c.nom_curs
FROM alumnes a
JOIN cursos c ON a.curs_id = c.id;      </pre>
  
    <h3> Altres consells d‚Äôoptimitzaci√≥</h3>
    <ul>
      <li> Usa <code>BULK COLLECT</code> i <code>FORALL</code> per treballar amb grans volums en PL/SQL</li>
      <li> Utilitza particions en taules molt grans</li>
      <li> Evita bloquejos i transaccions llargues</li>
    </ul>
  
    <h3> Resum de bones pr√†ctiques</h3>
    <ul>
      <li> Coneix el model de dades i el volum</li>
      <li> Usa EXPLAIN PLAN sovint</li>
      <li> Mant√©n estad√≠stiques al dia</li>
      <li> Indexa amb criteri</li>
      <li> Millora consultes repetitives o lentes</li>
    </ul>
  </section>
  



  <section id="optimitzacio-oracle">
    <h2> Optimitzaci√≥ en Oracle</h2>
  
     <h3>üìà L'optimitzador</h3>
    <p> Oracle utilitza un component anomenat <strong>optimitzador</strong> per determinar el millor 
      pla d‚Äôexecuci√≥ per a una consulta SQL.
      L‚Äôobjectiu √©s minimitzar el temps d‚Äôexecuci√≥ i l‚Äô√∫s de recursos.
    </p>
        
    <h3>üìä Estad√≠stiques</h3>
    <p>ORACLE utilitza un optimitzador CBO (basat en costos calculats amb estad√≠stiques)</p>
    <p> L‚Äôoptimitzador CBO utilitza <strong>estad√≠stiques</strong> sobre les taules, columnes i √≠ndexs 
      per decidir l‚Äôestrat√®gia d‚Äôexecuci√≥.     </p>
  
    <h4> Com generar estad√≠stiques</h4>
    <pre>EXEC DBMS_STATS.GATHER_TABLE_STATS('USUARI', 'TAULA');
-- Actualitzar estad√≠stiques
EXEC DBMS_STATS.GATHER_TABLE_STATS(ownname=>'USUARI', tabname=>'ALUMNES');
--
execute dbms_stats.gather_table_stats(‚Äòesquema‚Äô.‚Äôtaula‚Äô);
execute dbms_stats.gather_schema_stats(‚Äòesquema‚Äô);      </pre>
    
    <p><strong>‚ö†Ô∏è Per tant, √©s molt importat crear tasques programades que realitzen esta 
      actualitzaci√≥ fora d'hores de c√†rrega de treball</strong></p>    
  
    <h4>Tamb√© es poden automatitzar mitjan√ßant tasques de manteniment o recollida autom√†tica de l‚ÄôOracle Scheduler.</h4>
  
    <h3>üß™ EXPLAIN PLAN</h3>
    <p> Aquesta ordre permet visualitzar el pla que Oracle seguir√† per executar una consulta (sense executar-la realment). 
      Mostra si s‚Äôutilitzen √≠ndexs, escaneigs complets, joins, etc.    Ajuda a detectar consultes lentes o mal optimitzades.
    </p>
    <ul> S'usa principalment per:
      <li>Analitzar rendiment</li>
      <li>Detectar colls de botella</li>
      <li>Veure si s'estan usant index</li>
      <li>Entendre perqu√® √©s lenta una consulta</li>
      <li>Ajuda a optimitzar una SQL</li>
    </ul>
   
    <h4> Exemple d‚Äô√∫s</h4>
    <pre>EXPLAIN PLAN FOR  SELECT * FROM alumnes WHERE edat > 18;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);      </pre>
  
      <p>En Oracle SQL Developer pots fer un EXPLAIN PLAN de manera molt senzilla: </p>
      <li>1: Escriu la teva consulta al worksheet, selecciona la consulta (o deixa el cursor dins), Fes clic al bot√≥ ‚ÄúExplain Plan‚Äù (icona amb una lupa o arbre) o 
        Tamb√© pots pr√©mer F10. ‚ûú ‚ûú  SQL Developer mostrar√† el pla d‚Äôexecuci√≥ en una pestanya inferior. ‚ö†Ô∏è Aix√≤ no executa la consulta, nom√©s mostra el pla estimat.</li>
      <li>2: Amb EXPLAIN PLAN manualment. (Com s'ha vist abans)</li>
      <li>3: Veure el pla real (molt recomanat). Executa la consulta normalment (F9), Ves a la pestanya ‚ÄúAutotrace‚Äù (si est√† activada), (Si no la veus:View > Autotrace) </li>

    <h4> Resultats comuns:</h4>
    <ul>
      <li><code>TABLE ACCESS FULL</code> ‚Üí Oracle escaneja tota la taula</li>
      <li><code>INDEX RANGE SCAN</code> ‚Üí fa servir un √≠ndex parcial</li>
      <li><code>NESTED LOOPS</code>, <code>HASH JOIN</code> ‚Üí tipus d‚Äôestrat√®gies de join</li>
    </ul>
  
    <h3> Factors que afecten el pla d‚Äôexecuci√≥</h3>
    <ul>
      <li>Disponibilitat d‚Äô√≠ndexs</li>
      <li>Estad√≠stiques actualitzades</li>
      <li>Volum de dades</li>
      <li>Condicions de filtre i joins</li>
    </ul>
  
    <h3>‚ö†Ô∏è Errors habituals d‚Äôoptimitzaci√≥</h3>
    <ul>
      <li>Fer servir <code>SELECT *</code> en comptes de nom√©s les columnes necess√†ries</li>
      <li>Aplicar funcions sobre columnes en condicions (<code>WHERE UPPER(nom)</code>) ‚Üí trenca √≠ndexs</li>
      <li>No tenir √≠ndexs sobre claus foranes o condicions de filtre</li>
      <li>Oblidar actualitzar estad√≠stiques</li>
    </ul>
  
    <h3> Altres eines d‚Äôoptimitzaci√≥</h3>
    <ul>
      <li> <strong>DBMS_XPLAN</strong> ‚Üí mostra el pla d‚Äôexecuci√≥ amb m√©s detall</li>
      <li> <strong>AWR</strong> (Automatic Workload Repository) ‚Üí historial de rendiment</li>
      <li> <strong>ASH</strong> (Active Session History) ‚Üí activitat de sessions en temps real</li>
    </ul>
  
    <h3> Recomanacions generals</h3>
    <ul>
      <li> Revisa les consultes lentes amb EXPLAIN PLAN</li>
      <li> Actualitza estad√≠stiques sovint</li>
      <li> Fes servir √≠ndexs de manera estrat√®gica</li>
      <li> Prova diferents opcions de joins segons el volum i condicions</li>
      <li> Evita accessos complets si pots usar √≠ndexs</li>
    </ul>
  
    <h3> Exemple de consulta optimitzada</h3>
    <p>Consulta original (lenta):</p>
    <pre>SELECT * FROM alumnes WHERE TO_CHAR(data_naixement, 'YYYY') = '2005';      </pre>
  
    <p>Versi√≥ optimitzada:</p>
    <pre>SELECT * FROM alumnes
WHERE data_naixement BETWEEN TO_DATE('01/01/2005', 'DD/MM/YYYY')
                        AND TO_DATE('31/12/2005', 'DD/MM/YYYY');      </pre>
  
    <h3>üí¨ Conclusi√≥</h3>
    <p>
      L‚Äôoptimitzaci√≥ en Oracle es basa en la col¬∑laboraci√≥ entre el desenvolupador i l‚Äôoptimitzador del sistema. 
      Mantenir estad√≠stiques actualitzades, evitar males pr√†ctiques i revisar plans d‚Äôexecuci√≥ s√≥n claus per un rendiment √≤ptim.
    </p>
  </section>
  
  
  <section id="eines-optimitzacio">
    <h2> Eines d'optimitzaci√≥ en Oracle</h2>
  
    <h3>üéØ Objectiu</h3>
    <p>      Aquestes eines permeten <strong>analitzar el rendiment</strong> de consultes SQL, sessions i c√†rregues del sistema, ajudant a diagnosticar colls d‚Äôampolla i a optimitzar els accessos a dades.
    </p>
  
    <hr>
  
    <h3> 1. EXPLAIN PLAN</h3>
    <p>      Mostra el pla d‚Äôexecuci√≥ previst per Oracle per a una consulta. Ajuda a detectar si s‚Äôutilitzen √≠ndexs o si es fa un escaneig complet de taula.
    </p>
    <pre>EXPLAIN PLAN FOR
SELECT * FROM alumnes WHERE edat > 18;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);      </pre>
  
    <p><strong>Sortides habituals:</strong></p>
    <ul>
      <li><code>TABLE ACCESS FULL</code> ‚Üí acc√©s complet (lenta)</li>
      <li><code>INDEX RANGE SCAN</code> ‚Üí acc√©s parcial mitjan√ßant √≠ndex</li>
      <li><code>HASH JOIN</code>, <code>NESTED LOOPS</code> ‚Üí estrat√®gies de join</li>
    </ul>
  
    <hr>
  
    <h3> 2. DBMS_XPLAN</h3>
    <p>      Paquet que permet mostrar el pla d‚Äôexecuci√≥ amb m√©s claredat, incloent cost, l√≠nies estimades, filtre aplicat, etc.      </p>
  
    <h4> Exemple:</h4>
    <pre>SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);      </pre>
  
    <p>Per veure el pla real d‚Äôuna consulta ja executada:</p>
    <pre>SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST'));      </pre>
  
    <hr>
  
    <h3> 3. AUTOTRACE</h3>
    <p>      Mostra autom√†ticament el pla d‚Äôexecuci√≥ i estad√≠stiques despr√©s d‚Äôexecutar una consulta.    </p>
  
    <h4> Activar AUTOTRACE a SQL*Plus:</h4>
    <pre>SET AUTOTRACE ON;
SELECT * FROM alumnes WHERE edat > 18;      </pre>
  
    <p><strong>Resultat:</strong> mostra el cost, nombre de lectures, l√≠nies retornades i acc√©s utilitzat.</p>
  
    <hr>
  
    <h3> 4. AWR (Automatic Workload Repository)</h3>
    <p>
      Recull m√®triques de rendiment cada hora. Permet fer comparatives, generar informes i detectar canvis de rendiment.
    </p>
  
    <h4>üìù Informes AWR:</h4>
    <pre>@$ORACLE_HOME/rdbms/admin/awrrpt.sql      </pre>
  
    <ul>
      <li>Comparativa entre snapshots</li>
      <li>Identificaci√≥ de top SQL (consultes m√©s pesades)</li>
      <li>√ös de recursos (CPU, I/O, etc.)</li>
    </ul>
  
    <hr>
  
    <h3> 5. ASH (Active Session History)</h3>
    <p>
      Mostra l‚Äôactivitat de les sessions que han estat actives en els darrers minuts. 
      Ideal per veure quines consultes estan causant c√†rrega.
    </p>
  
    <h4>üîç Exemple de consulta ASH:</h4>
    <pre>SELECT sql_id, session_id, wait_class, event, sample_time
FROM v$active_session_history
WHERE sample_time > SYSDATE - 1/24;      </pre>
  
    <p><strong>Requereix:</strong> llic√®ncia Oracle Enterprise Edition + Pack Diagn√≤stic</p>
  
    <hr>
  
    <h3> Altres eines √∫tils</h3>
    <ul>
      <li><code>V$SQL</code>, <code>V$SESSION</code> ‚Üí consultes actives i sessions en curs</li>
      <li>SQL Developer ‚Üí gr√†fics de sessions, consultes i objectes bloquejats</li>
    </ul>
  
    <hr>
  
    <h3> Bones pr√†ctiques</h3>
    <ul>
      <li> Revisa plans amb EXPLAIN PLAN abans de desplegar consultes</li>
      <li> Activa AUTOTRACE si treballes amb SQL*Plus</li>
      <li> Usa AWR i ASH per detectar canvis de rendiment entre per√≠odes</li>
      <li>‚ö†Ô∏è Evita EXPLAIN PLAN sobre consultes complexes sense context</li>
    </ul>
  
    <h3> Conclusi√≥</h3>
    <p>
      Les eines d‚Äôoptimitzaci√≥ d‚ÄôOracle et permeten <strong>monitorar i millorar</strong> el comportament del teu sistema, evitant colls d‚Äôampolla i millorant l‚Äôexperi√®ncia d‚Äôusuari.
    </p>
  </section>
  
  
  <section id="optimitzacio-objectes">

<h1>Optimitzaci√≥ dels objectes de la bbdd</h1>

    <h2>Fragmentaci√≥ de Taules en Oracle</h2>
  
    <h4>üîç Qu√® √©s la fragmentaci√≥ de taules?</h4>
    <p>
      La <strong>fragmentaci√≥</strong> fa refer√®ncia a l'espai de mem√≤ria mal aprofitat dins d'una taula (o √≠ndex) a la base de dades.
      Pot provocar que certes operacions, com escaneigs complets de taula o acc√©s via √≠ndex, siguin menys eficients.
    </p>
  
    <h4> Causes comunes de fragmentaci√≥ en Oracle</h4>
    <ul>
      <li><strong>Insercions i esborrats freq√ºents</strong>: deixen "forats" dins dels blocs que no es reomplen autom√†ticament.</li>
      <li><strong>Actualitzacions amb valors m√©s grans</strong>: poden generar <em>row chaining</em>.</li>
      <li><strong>Canvis en PCTFREE o PCTUSED</strong>: afecten com s'administra l'espai dins dels blocs.</li>
    </ul>
  
    <h4> Conseq√º√®ncies de la fragmentaci√≥</h4>
    <ul>
      <li>Rendiment m√©s lent en consultes.</li>
      <li>M√©s escaneigs de blocs del necessari.</li>
      <li>Increment d'I/O.</li>
    </ul>
  
    <h4>üß∞ Com detectar la fragmentaci√≥</h4>
    <pre><code>ANALYZE TABLE nom_taula COMPUTE STATISTICS;</code></pre>
    <pre><code>SELECT table_name, blocks, empty_blocks, avg_space
FROM dba_tables
WHERE table_name = 'NOM_TAULA';      </code></pre>
    <p>Tamb√© pots consultar les vistes <code>DBA_SEGMENTS</code> i <code>DBA_EXTENTS</code>.</p>
  
    <h4>üõ†Ô∏è Solucions per reduir o eliminar la fragmentaci√≥</h4>
    <ul>
      <li>
        <strong>Reorganitzar la taula:</strong>
        <pre><code>ALTER TABLE nom_taula MOVE;
alter table nom_taula move [compress];   </code></pre>
      </li>
      <li>
        <strong>Exportar i importar:</strong> amb <code>exp/imp</code> o <code>DataPump</code>.
      </li>
      <li>
        <strong>Shrink de taules:</strong>
        <pre><code>ALTER TABLE nom_taula ENABLE ROW MOVEMENT;
ALTER TABLE nom_taula SHRINK SPACE;           </code></pre>
      </li>
      <li>
        <strong>Rebuild d'√≠ndexs:</strong>
        <pre><code>ALTER INDEX nom_index REBUILD;</code></pre>
      </li>
    </ul>
  
    <h4> Bones pr√†ctiques</h4>
    <ul>
      <li>Monitoritzar l‚Äô√∫s de l‚Äôespai amb regularitat.</li>
      <li>Evitar esborrats massius sense planificaci√≥.</li>
      <li>Configurar correctament <code>PCTFREE</code> i <code>PCTUSED</code> segons el patr√≥ d‚Äô√∫s.</li>
    </ul>


<h2>üìä √çndexs</h2>
<p>   Els <strong>√≠ndexs</strong> permeten accedir m√©s r√†pidament a dades. Cal usar-los correctament: </p>
 
<h4>üîß Crear un √≠ndex</h4>
<pre>CREATE INDEX idx_nom ON alumnes(nom);  </pre>

<pre>create index nom_ind on nom_taula (camp1, camp2,..);
alter index nom_ind rebuild;</pre>

  <p>Quan es crea una taula amb una clau primaria o unique, ORACLE crea un √≠ndex autom√†ticament</p>
  <h4>Tipus √≠ndex</h4>
  <pre>create [bitmap | unique] index nom_ind on nom_taula (camp1, camp2,..);
alter index nom_ind rebuild;   </pre>

  <h4>Com explorar els √≠ndex (en DD)</h4>  
  <pre>select index_name , index_type ,table_name , tablespace_name , secondary 
from all_indexes where table_name = 'TAULA_A_CONSULTAR';      </pre>

<h2>Particionament</h2>
<pre>create table ....( ) partition by range(nomcamp) (....);</pre>

    <h4> En que consisteix el particionament?</h4>
    <p>El particionament consisteix a <strong>dividir l√≤gica i f√≠sicament una taula gran</strong> en parts m√©s petites 
      anomenades <em>particions</em>, de manera que el sistema pugui gestionar-les de forma m√©s eficient.</p>
  

    <h4> Per a qu√® serveix?</h4>
<p>Per exemple imaginem una taula de factures, on tenim el detall de la nostra facturaci√≥
   al llarg de 9 anys, 2017, 2018‚Ä¶ 2025, si volgu√©rem fer:</p>
<p><code> SELECT SUM(total_fac) FROM facturacio WHERE any = 2019;</code></p>
<p>En aquest exemple s'hauria de rec√≥rrer tota la taula (imaginem que parlem de 30 milions de registres en total,
   √©s molt no?), per aquest motiu un criteri possible per a particionar la taula seria per l'any de la
    data de la factura</p>

    <ul>
      <li> Millora del rendiment de consultes.</li>
      <li> Facilita el manteniment (per exemple, eliminar o arxivar particions antigues).</li>
      <li> Millor gesti√≥ de l'emmagatzematge.</li>
      <li> Paral¬∑lelisme en operacions.</li>
    </ul>
  
    <h4> Tipus de particionament</h4>

    <h4>1. Particionament per rang (<code>RANGE</code>)</h4>
    <p>Divideix segons un valor dins d‚Äôun rang (ex: dates).</p>
    <pre><code>CREATE TABLE vendes (
    id NUMBER,
    data_venda DATE,
    import NUMERIC
)
PARTITION BY RANGE (data_venda) (
    PARTITION p2019 VALUES LESS THAN (TO_DATE('2020-01-01', 'YYYY-MM-DD')),
    PARTITION p2020 VALUES LESS THAN (TO_DATE('2021-01-01', 'YYYY-MM-DD')),
    PARTITION p2021 VALUES LESS THAN (TO_DATE('2022-01-01', 'YYYY-MM-DD')),
    PARTITION p_future VALUES LESS THAN (MAXVALUE)
);</code></pre>

    <h4>2. Particionament per llista (<code>LIST</code>)</h4>
    <p>Divideix segons valors espec√≠fics.</p>
    <pre><code>CREATE TABLE clients (
    id NUMBER,
    nom VARCHAR2(50),
    regi√≥ VARCHAR2(20)
)
PARTITION BY LIST (regi√≥) (
    PARTITION p_nord VALUES ('NORD'),
    PARTITION p_sud VALUES ('SUD'),
    PARTITION p_est VALUES ('EST'),
    PARTITION p_oest VALUES ('OEST')
);</code></pre>

  <!--  <h4>3. Particionament per hash (<code>HASH</code>)</h4>
    <p>Divideix les files aleat√≤riament segons una funci√≥ hash.</p>
    <pre><code>CREATE TABLE productes (
    id NUMBER,
    nom VARCHAR2(100)
)
PARTITION BY HASH (id)
PARTITIONS 4;</code></pre>

    <h4>4. Particionament compost (<code>COMPOSITE</code>)</h4>
    <p>Combina dos tipus de particionament, t√≠picament RANGE + HASH o RANGE + LIST.</p>
    <pre><code>CREATE TABLE ordres (
    id NUMBER,
    data_ordre DATE,
    client_id NUMBER
)
PARTITION BY RANGE (data_ordre)
SUBPARTITION BY HASH (client_id)
SUBPARTITIONS 4
(
    PARTITION p_2023 VALUES LESS THAN (TO_DATE('2024-01-01','YYYY-MM-DD')),
    PARTITION p_2024 VALUES LESS THAN (TO_DATE('2025-01-01','YYYY-MM-DD'))
);</code></pre>  -->
  
<h4> Com saber quina estrat√®gia escollir?</h4>
<p>Dep√®n de:</p>
<ul>
  <li>El tipus de consultes habituals.</li>
  <li>La mida de les dades.</li>
  <li>El tipus de columna (distribuci√≥, cardinalitat).</li>
  <li>Necessitats de manteniment i arxiu.</li>
</ul>

<h4> Altres operacions √∫tils</h4>
<pre><code>-- Afegir partici√≥
ALTER TABLE vendes ADD PARTITION p2022 VALUES LESS THAN (TO_DATE('2023-01-01', 'YYYY-MM-DD'));

-- Eliminar partici√≥
ALTER TABLE vendes DROP PARTITION p2020;

-- Consultar nom√©s una partici√≥
SELECT * FROM vendes 
WHERE data_venda >= TO_DATE('2021-01-01', 'YYYY-MM-DD');</code></pre>

    <h4> Consultar si una taula est√† particionada</h4>
    <pre><code>SELECT table_name, partitioning_type
FROM user_part_tables;</code></pre>
  

<h2>Optimitzaci√≥ de consultes</h2>
<p>consultesOracle activa un optimitzador de consultes autom√†ticament i reescriu les consultes 
  si ho estima necessari. Realitza les seg√ºents operacions</p>
<ul>
  <li>Avalua expressions i condicions </li>
  <li>Transforma sent√®ncies complexes</li>
  <li>Transforma vistes en consultes</li>
  <li>Avalua els JOIN i ordena el acc√©s i la forma d‚Äôacc√©s</li>
</ul>


<h3>Pla d'execuci√≥</h3>
<pre>
  Oracle guarda en el DD , les estad√≠stiques de les taules
  En la Vista ==> user_tables</pre>
  <p>Usant les estad√≠stiques (DD) , el monitor de rendiment i el registre d‚Äôerrors, proposa un pla d‚Äôexecuci√≥, 
    que determina com es pot resoldre una consulta de la forma m√©s eficient. Una vegada executades les consultes, 
    els plans d‚Äôexecuci√≥ s‚Äôemmagatzemen en <strong>la cau de consultes</strong></p>
<p>Cada vegada que executem una sent√®ncia una de les coses que fa Oracle √©s crear un pla d'execuci√≥ 
  de la sent√®ncia. (SELECT, UPDATE, INSERT o DELETE). 
  Un pla d'execuci√≥ defineix la forma en qu√® Oracle cerca o grava les dades. 
  Decideix, per exemple, si usar√† o no els √≠ndexs en una sent√®ncia SELECT</p>    
<pre>DELETE PLAN_TABLE;
  EXPLAIN PLAN FOR SELECT * FROM T_PEDIDOS WHERE CODPEDIDO = 5;
  select * from plan_table;</pre>

<p>El Pla d'execuci√≥ ¬°¬° Usa estad√≠stiques de taules !!</p>
<p>Un usuari necessita tindre perm√≠s per revisar els plans d‚Äôexecuci√≥ de les consultes</p>
<pre>
  grant select_catalog_role to nom_usu;
  grant select any dictionary to nom_usu;</pre>
<p>El SQL Developer permet consultar el pla d‚Äôexecuci√≥ de forma gr√†fica, 
  polsant F10 sobre la consulta abans de llan√ßar-la</p>
<p>El SQL*Plus permet consultar el pla d‚Äôexecuci√≥ de les consultes, 
  executant la seg√ºent instrucci√≥ <code> set autotrace traceonly explain</code></p>  

<h3>SQL Tunning Advisor</h3>
<p>Un usuari necessita tindre perm√≠s per executar el SQL tuning advisor</p>
<p>En una SQL, abans d‚Äôexecutar, pulsa ctrl + F12</p>
<p>I despr√©s, run SQL amb alt + F11</p>

<h3>Monitor d'operacions</h3>
<pre>Es consulta des del paquet DBMS_SQL_MONITOR, 
  - procediment report_sql_monitor
  - vista V$SQL_MONITOR</pre>

<h3>Operacions particulars d'ORACLE</h3>
<pre>d‚ÄôOracleInsercions massives : SQL Loader
  Insert Append: INSERT /*+ APPEND */ INTO NOM_taula VALUES (...);
  Nologging alter table t1 nologging;
  Truncate table truncate table t1 ;
  Intercanvi de particions
  Vistes materialitzades. Guarden consulta i dades. Solen guardar c√†lculs massius
  Merge Combina la inserci√≥ i la modificaci√≥ en una sola instrucci√≥
  Hints
    Els hints s'incorporen a una sent√®ncia DML en forma de comentari i han d'anar just darrere del comando principal. Per exemple, si es tractara d'una sent√®ncia SELECT el format seria el seg√ºent:
  SELECT /*+ COMANDO-HINT */ ...

  S‚Äôha d‚Äôanar amb compte amb estes operacions, donat que redueixen la seguretat i la possibilitat de recuperaci√≥ davant d‚Äôoperacions no desitjades !!
</pre>

</section>

<section id="altres-recursos">

       <hr><h3>Rep√†s...</h3>
    <div id="progress-container">
    <div id="progress-bar"></div>  </div>
    <!-- <div id="percentatge-text">0%</div>  -->

    <div class="quiz-container">
        <h4 id="pregunta-text"></h4>
        <div id="options-container" class="options">
        </div>

        <p id="feedback"></p>
        <button id="btn-seguent" onclick="seguentPregunta()">      ‚ûï Seg√ºent pregunta </button>
        <button onclick="carregarPreguntes()">üîÅ Reiniciar</button>
 

</section>


</main>


<script>

  // Per poder copiar codi en el porta-retalls. S'ha de posar un bot√≥ en cada <pre>
      //  <div class="pre-container">
      //    <button class="copy-button">Copia Codi !</button>
  document.addEventListener('DOMContentLoaded', function () {
    const buttons = document.querySelectorAll('.copy-button');

    buttons.forEach(button => {
      button.addEventListener('click', function () {
        const code = this.nextElementSibling.innerText;
        navigator.clipboard.writeText(code).then(() => {
          this.innerText = ' ‚úî Copiat!';
          setTimeout(() => this.innerText = 'Copia Codi !', 3000);
        });
      });
    });
  });


//  Per fer test final
  // Primer es crea un bancDePreguntes   const
  // i despr√®s es carrega una pregunta aleatoria    function
  // per ultim la funcio de comprobar resposta per a quan es polse un bot√≥

let bancDePreguntes = [];
let preguntesBarrejades = [];
let indexPreguntaActual = 0;
let puntuacio = 0;

function barrejar(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function actualitzarProgres() {
    const percentatge =
        (indexPreguntaActual / preguntesBarrejades.length) * 100;
    document.getElementById('progress-bar').style.width =
        percentatge + "%";
}

function actualitzarPercentatge() {
    const percentatge = Math.round(
        (puntuacio / preguntesBarrejades.length) * 100
    );
    document.getElementById('percentatge-text').innerText =""
       // `Encerts: üéØ ${percentatge}%`;
}


function carregarPreguntes() {
    fetch('preguntes/preguntes51.json')
        .then(res => res.json())
        .then(data => {
            bancDePreguntes = data;
            preguntesBarrejades = [...bancDePreguntes];
            barrejar(preguntesBarrejades);
            puntuacio = 0;
            indexPreguntaActual = 0;
            mostrarPregunta();
        })
        .catch(err => {
            console.error(err);
            document.getElementById('pregunta-text').innerText =
                "Error carregant les preguntes üò¢";
        });
        //document.getElementById('percentatge-text').innerText = "0%";

}

function mostrarPregunta() {

    // Si ja no queden preguntes
    if (indexPreguntaActual >= preguntesBarrejades.length) {
        document.getElementById('pregunta-text').innerText =
            "üéâ Has acabat totes les preguntes!";
        document.getElementById('options-container').innerHTML = "";
        document.getElementById('feedback').innerHTML =
        `Has encertat <strong>${puntuacio}</strong> de 
        <strong>${preguntesBarrejades.length}</strong> preguntes.`;
        document.getElementById('btn-seguent').disabled = true;
        document.getElementById('progress-bar').style.width = "100%";
        actualitzarProgres();
        return;
    }

    const pregunta = preguntesBarrejades[indexPreguntaActual];

    document.getElementById('pregunta-text').innerText = pregunta.titol;

    const container = document.getElementById('options-container');
    container.innerHTML = "";

    pregunta.opcions.forEach(opcio => {
        const btn = document.createElement('button');
        btn.innerText = opcio.text;
        btn.onclick = () => comprovaResposta(opcio.correcte, btn);
        container.appendChild(btn);
    });

    document.getElementById('feedback').textContent = "";
    document.getElementById('btn-seguent').disabled = true;
    actualitzarProgres();

}


function comprovaResposta(esCorrecte, element) {
    const feedback = document.getElementById('feedback');

    document
        .querySelectorAll('#options-container button')
        .forEach(btn => btn.disabled = true);

    if (esCorrecte) {
        feedback.textContent = "‚úÖ Correcte! Molt b√©.";
        element.style.background = "#d4edda";
        puntuacio++;
    } else {
        feedback.textContent = "‚ùå Incorrecte.";
        element.style.background = "#f8d7da";
    }
    //actualitzarPercentatge();
    document.getElementById('btn-seguent').disabled = false;
}

function seguentPregunta() {
    indexPreguntaActual++;
    mostrarPregunta();
}

 

// Executar en carregar la p√†gina
window.onload = carregarPreguntes;


</script>

</body>
</html>
